#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
\renewcommand*{\equationautorefname}[1]{}
\renewcommand{\chapterautorefname}{\negthinspace}
\renewcommand{\sectionautorefname}{\negthinspace}
\renewcommand{\subsectionautorefname}{\negthinspace}
\renewcommand{\subsubsectionautorefname}{\negthinspace}
\renewcommand{\figureautorefname}{\negthinspace}
\renewcommand{\tableautorefname}{\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage,fleqn
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\begin_inset CommandInset label
LatexCommand label
name "chap:Introduction"

\end_inset


\end_layout

\begin_layout Standard
The boolean satisfiability problem (
\emph on
SAT
\emph default

\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "SAT"
description "Boolean Satisfiability Problem"

\end_inset

) is a decision problem
\begin_inset Foot
status open

\begin_layout Plain Layout
A decision problem is a problem with a YES/NO answer.
 In formal languages theory, such a problem can be viewed as a formal language
 containing strings (problem instances) for which the answer is YES.
\end_layout

\end_inset

 where we are given a logical formula 
\begin_inset Formula $F$
\end_inset

 over some variables and we ask if there is a satisfying assignment for
 it.
 A satisfying assignment simply means an assignment of truth values to the
 variables so that the formula evaluates to truth.
 
\emph on
SAT
\emph default
 was the very first problem to be proven NP-complete
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "NP"
description "Nondeterministic Polynomial"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "Cook1971"

\end_inset

 and remains one of the most frequently studied problems in computational
 complexity theory.
 Although finding satisfying truth assignments or proving unsatisfiability
 seems to be hard in general, there are tools---solvers (PicoSAT, MiniSat,
 Glucose, Lingeling, etc.)---that can deal with really large instances in
 practice.
 
\end_layout

\begin_layout Standard
After the boolean satisfiability problem was shown NP-complete, people found
 literally hundreds of problems in graph theory, mathematical programming,
 puzzles and games that are NP-complete, meaning that knowing how to solve
 one of these problems in polynomial-time would imply polynomial-time algorithms
 for all of them.
 One of such problems is the so-called 
\emph on
Hamiltonian-Cycle
\emph default
 problem.
 In this problem we want to answer the question whether there is a cycle
 in a given graph that starts in a given vertex and goes through all the
 vertices, but visits each of them only once.
 The optimization version of this problem, the so-called 
\emph on
Travelling-Salesman 
\emph default
problem, is NP-hard.
 It is about finding a hamiltonian cycle with the lowest edge cost possible.
 
\end_layout

\begin_layout Standard
Solving 
\emph on
SAT
\emph default
 is not only a theoretical challenge.
 There are a lot of practical applications that can be modeled using boolean
 functions.
 Examples of such problems in electronic design automation (EDA) include
 formal equivalence checking, model checking, formal verification of pipelined
 microprocessors 
\begin_inset CommandInset citation
LatexCommand cite
key "Bryant1999"

\end_inset

, automatic test pattern generation 
\begin_inset CommandInset citation
LatexCommand cite
key "Larrabee2006"

\end_inset

, routing of FPGAs 
\begin_inset CommandInset citation
LatexCommand cite
key "GSR2002"

\end_inset

, planning 
\begin_inset CommandInset citation
LatexCommand cite
key "Kautz2006"

\end_inset

, and scheduling 
\begin_inset CommandInset citation
LatexCommand cite
key "HDH2004"

\end_inset

 problems.
 In this thesis we consider the 
\emph on
Integer-Factorization 
\emph default
problem and we analyze the way of reducing it to 
\emph on
SAT.
 
\emph default
The purpose of this is to obtain a set of similarly-structured 
\emph on
SAT 
\emph default
instances
\begin_inset Foot
status open

\begin_layout Plain Layout
By the way the reduction works, formulas generated for factorization problem
 of two distinct 
\begin_inset Formula $n$
\end_inset

-bit integers do have the same size and very similar structure.
 Yet these formulas may differ when it comes to the satisfiability.
\end_layout

\end_inset

 and inspect their properties.
 We want to evaluate the performance of modern 
\emph on
SAT 
\emph default
solvers on these particular problem instances.
 
\end_layout

\begin_layout Standard
We also consider the 
\emph on
OWA-Winner 
\emph default
problem (an optimization problem in the election and voting theory) and
 the way of reducing this problem to 
\emph on
SAT-CNF.
 
\emph default
In the 
\emph on
OWA-Winner
\emph default
 problem there are agents and items.
 Each agent has to rate each item, which is done by assigning a number (intrinsi
c utility) to the item.
 Then the purpose is to find a set of items that maximizes the general utility
 over all agents.
 The actual utility that the agent gains from an item might be different
 then the intrinsic utility that was assigned to the item by the agent,
 and depends on the order in which an agent ranks the items.
\end_layout

\begin_layout Standard
There are two main goals of this thesis.
 The first and the most important one is a reduction of the 
\emph on
Integer-Factorization 
\emph default
and 
\emph on
OWA-Winner 
\emph default
problems to 
\emph on
SAT-CNF 
\emph default
in a possibly efficient way.
 The second goal is related to the experimental exploration of the formulas
 obtained from the reductions.
 We investigate two main metrics in our experiments: 
\emph on
clauses-to-variables ratio 
\emph default
and 
\emph on
running time.

\emph default
 
\end_layout

\begin_layout Standard
The thesis is organized as follows.
 First, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Preliminaries"

\end_inset

, we introduce the boolean satisfiability problem 
\emph on
SAT
\emph default
, the 
\emph on
Integer-Factorization 
\emph default
problem and the 
\emph on
OWA-Winner 
\emph default
problem.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Boolean-Satisfiability"

\end_inset

, we discuss the formal settings needed to understand what boolean formulas
 are, what is a truth assignment and valuation.
 We discuss the satisfiability and unsatisfiability, conjunctive normal
 form and we show that it is possible to convert all the booleans formulas
 to 
\emph on
SAT-CNF 
\emph default
efficiently using the transformation that preserves the satisfiability property
 of the original formula (Tseytin transformation).
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Integer-Factorization"

\end_inset

, we introduce
\emph on
 
\emph default
the 
\emph on
Integer-Factorization 
\emph default
problem.
 We mention the importance of this problem in modern public-key cryptography.
 We briefly talk about two elementary algorithms of factoring integers:
 trial division and Fermat's factorization method.
 We also list some more advanced algorithms for tackling the 
\emph on
Integer-Factorization 
\emph default
problem.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-OWA-Winner-Problem"

\end_inset

, we introduce the 
\emph on
OWA-Winner 
\emph default
problem giving the intuition behind it as well as real-world applications
 of this problem.
 We also give an integer linear programming formulation of the general OWA-Winne
r problem.
 This is important since in the next chapter, we develop a 
\emph on
SAT-CNF 
\emph default
encoding of the 
\emph on
OWA-Winner 
\emph default
problem (its decision version to be precise) based on this 
\emph on
ILP 
\emph default
formulation.
 
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Reducing-Selected-Computational"

\end_inset

, we carefully develop a 
\emph on
SAT-CNF 
\emph default
encoding of the 
\emph on
Integer-Factorization 
\emph default
problem based on the work of Srebrny 
\begin_inset CommandInset citation
LatexCommand cite
key "Srebrny2004"

\end_inset

 as well as the 
\emph on
OWA-Winner 
\emph default
problem.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Basic-Notions-and"

\end_inset

, we introduce basic notions and definitions of objects used to express
 boolean constraints.
 We define an important notion of sequences of boolean variables and establish
 conventions to be used in the rest of the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Reducing-Selected-Computational"

\end_inset

.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Reducing-Integer-Factorization"

\end_inset

, we explain the encoding of constraints necessary to reduce the 
\emph on
Integer-Factorization 
\emph default
to 
\emph on
SAT-CNF.
 
\emph default
Among others, we encode both the addition and multiplication of sequences
 of boolean variables.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Reducing-OWA-Winner-to"

\end_inset

, we reduce the 
\emph on
OWA-Winner 
\emph default
problem (its decision version) to the 
\emph on
SAT-CNF.
 
\emph default
To do this, we first consider the efficient encodings of boolean cardinality
 constraints.
 We reduce both the general 
\emph on
OWA-Winner 
\emph default
problem and the approval version of
\emph on
 OWA-Winner 
\emph default
problem to 
\emph on
SAT-CNF.
 
\emph default
The latter reduction is more efficient in terms of the number of variables
 and clauses in generated formulas and relies to the greater degree on the
 encodings of boolean cardinality constraints.
 
\end_layout

\begin_layout Standard
In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Analysis-of-Structure"

\end_inset

, we investigate both the 
\emph on
clauses-to-variables ratio
\emph default
 and 
\emph on
running time 
\emph default
for selected instances of the 
\emph on
OWA-Winner 
\emph default
problem and 
\emph on
Integer-Factorization 
\emph default
problem.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Clauses-to-Variables"

\end_inset

, we focus on the 
\emph on
clauses-to-variables ratio.
 
\emph default
We mention that for randomly generated 
\emph on
SAT-CNF 
\emph default
instances there is a transition phenomenon (from satisfiability to unsatisfiabil
ity) when 
\emph on
clauses-to-variables ratio 
\emph default
approaches 
\begin_inset Formula $M=4.26$
\end_inset

.
 We investigate if this phenomenon also happens for the 
\emph on
SAT-CNF 
\emph default
instances generated both from the 
\emph on
Integer-Factorization 
\emph default
and
\emph on
 OWA-Winner 
\emph default
problem instances.
 In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:Running-Time"

\end_inset

, we analyze 
\emph on
running time 
\emph default
of the 
\emph on
PicoSAT 
\emph default
solver on the generated instances.
 We show 
\emph on
running time 
\emph default
may behave in really different ways on apparently quite similar problem
 instances for the 
\emph on
OWA-Winner 
\emph default
problem.
 
\end_layout

\begin_layout Standard
We conclude our work in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Conclusions"

\end_inset

.
\end_layout

\begin_layout Chapter
Preliminaries
\begin_inset CommandInset label
LatexCommand label
name "chap:Preliminaries"

\end_inset


\end_layout

\begin_layout Standard
We assume that the reader is familiar with basic notions regarding mathematics,
 logic and complexity theory.
 First, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Boolean-Satisfiability"

\end_inset

, we recall notions needed to understand the 
\emph on
SAT
\emph default
 problem.
 Then, in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-Integer-Factorization"

\end_inset

, we briefly discuss the 
\emph on
Integer-Factorization 
\emph default
problem with its applications and basic factorization algorithms.
 Finally, In 
\begin_inset CommandInset ref
LatexCommand formatted
reference "sec:The-OWA-Winner-Problem"

\end_inset

, we give an overview of the 
\emph on
OWA-Winner 
\emph default
problem and formulate this problem as an integer linear program.
 
\end_layout

\begin_layout Section
The Boolean Satisfiability and CNF
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Boolean-Satisfiability"

\end_inset


\end_layout

\begin_layout Standard
In this section we give a formal definition of concepts related to the boolean
 satisfiability and conjunctive normal form.
 The definitions below can be easily found in introductory mathematical
 logic and theory of computation textbooks such as a classical textbook
 on the computational complexity by Christos H.
 Papadimitriou (Chapter 4) 
\begin_inset CommandInset citation
LatexCommand cite
key "Papadimitriou1995"

\end_inset

.
 We define formally what we mean by a boolean formula.
\end_layout

\begin_layout Definition

\series bold
\begin_inset CommandInset label
LatexCommand label
name "Boolean-formula"

\end_inset


\series default
\emph on
Boolean formulas
\emph default
 are defined recursively as follows.
 A formula 
\begin_inset Formula $F$
\end_inset

 is either:
\end_layout

\begin_layout Enumerate
a boolean variable (a plain boolean variable is itself the simplest possible
 boolean formula)
\end_layout

\begin_layout Enumerate
another formula 
\begin_inset Formula $F_{1}$
\end_inset

 in parentheses
\end_layout

\begin_layout Enumerate
negation of another formula 
\begin_inset Formula $F_{1}$
\end_inset


\end_layout

\begin_layout Enumerate
conjunction of two other formulas 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset


\end_layout

\begin_layout Enumerate
disjunction of two other formulas 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset


\end_layout

\begin_layout Enumerate
implication (
\begin_inset Formula $F_{1}$
\end_inset

 implies 
\begin_inset Formula $F_{2}$
\end_inset

), where 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

 are two formulas
\end_layout

\begin_layout Enumerate
equivalence of 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

, where 
\begin_inset Formula $F_{1}$
\end_inset

 and 
\begin_inset Formula $F_{2}$
\end_inset

 are two formulas 
\end_layout

\begin_layout Standard
The definition above states a formal grammar used to generate the language
 of valid boolean formulas.
 It is important to mention the precedence of operators (from highest to
 lowest):
\end_layout

\begin_layout Enumerate
\begin_inset Formula $()$
\end_inset

 - parentheses have the highest priority
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\overline{x}$
\end_inset

 - negation (of 
\begin_inset Formula $x$
\end_inset

 )
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\wedge$
\end_inset

 - conjunction
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\vee$
\end_inset

 - disjunction
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $\Rightarrow$
\end_inset

 - implication
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Leftrightarrow$
\end_inset

 - equivalence
\end_layout

\begin_layout Standard
We introduce a concept of a truth assignment, which is simply an assignment
 of truth value to every variable in a boolean formula.
\end_layout

\begin_layout Definition

\emph on
Truth assignment
\series bold
\emph default
 
\series default
is a function 
\begin_inset Formula $\psi$
\end_inset

 that assigns a truth value to every variable in a formula 
\begin_inset Formula $F$
\end_inset

 (set of variables is denoted as 
\begin_inset Formula $\mathrm{vars}(F)$
\end_inset

): 
\begin_inset Formula $\psi:\mathrm{vars}(F)\rightarrow\{\mathrm{TRUE},\mathrm{FALSE}\}$
\end_inset


\end_layout

\begin_layout Standard
Having a truth assignment, we replace all variables in a formula with their
 respective truth values.
 Then by using well known rules of logic, we simplify the expression consisting
 of truth values and logical connectives (operators) to obtain a single
 truth value.
 This is known in logic as a valuation.
\end_layout

\begin_layout Definition

\emph on
(Valuation)
\emph default
 Let 
\begin_inset Formula $\psi$
\end_inset

 be a truth assignment to variables of 
\begin_inset Formula $F$
\end_inset

.
 We define 
\begin_inset Formula $\Psi:\{F|F\,\mathrm{is\,a\,boolean\,formula}\}\times\{\psi|\psi\,\mathrm{is\,a\,truth\,assignment\,to}\,F\}\rightarrow\{\mathrm{TRUE,FALSE}\}$
\end_inset

 (valuation of 
\begin_inset Formula $F$
\end_inset

 under assignment 
\begin_inset Formula $\psi$
\end_inset

) in the following recursive way:
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi(b,\psi)=\psi(b)$
\end_inset

 (a valuation of a formula consisting of a single boolean variable is simply
 the truth value of this variable)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi((F_{1}),\psi)=\Psi(F_{1},\psi)$
\end_inset

 (parentheses do not affect valuation)
\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi(\overline{F_{1}},\psi)=\begin{cases}
\mathrm{TRUE} & \mathrm{if\,}\Psi(F_{1},\psi)=\mathrm{FALSE}\\
\mathrm{FALSE} & \mathrm{otherwise}
\end{cases}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi(F_{1}\wedge F_{2},\psi)=\begin{cases}
\mathrm{TRUE} & \mathrm{if\,}\Psi(F_{1},\psi)=\mathrm{TRUE\,and}\,\Psi(F_{2},\psi)=\mathrm{TRUE}\\
\mathrm{FALSE} & \mathrm{otherwise}
\end{cases}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi(F_{1}\vee F_{2},\psi)=\begin{cases}
\mathrm{TRUE} & \mathrm{if\,}\Psi(F_{1},\psi)=\mathrm{TRUE\,or}\,\Psi(F_{2},\psi)=\mathrm{TRUE}\\
\mathrm{FALSE} & \mathrm{otherwise}
\end{cases}$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi(F_{1}\Rightarrow F_{2},\psi)=\Psi(\overline{F_{1}}\vee F_{2})$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $\Psi(F_{1}\Leftrightarrow F_{2},\psi)=\Psi((F_{1}\Rightarrow F_{2})\wedge(F_{2}\Rightarrow F_{1}),\psi)$
\end_inset


\end_layout

\begin_layout Standard
If there is an assignment (at least one) that valuates to truth, we call
 a formula satisfiable.
 We give a formal definition below.
\end_layout

\begin_layout Definition

\emph on
(Satisfiability)
\series bold
\emph default
 
\series default
Let 
\begin_inset Formula $F$
\end_inset

 be a boolean formula and 
\begin_inset Formula $\Psi$
\end_inset

 be a valuation function.
 We call 
\begin_inset Formula $F$
\end_inset

 satisfiable iff there exists a satisfying assignment 
\begin_inset Formula $\psi$
\end_inset

 such that: 
\begin_inset Formula $\Psi(F,\psi)=\mathrm{TRUE}$
\end_inset

.
 If a formula is not satisfiable then we call it unsatisfiable.
\end_layout

\begin_layout Standard
To illustrate the definition below we give an example of a satisfiable boolean
 formula.
\end_layout

\begin_layout Example
Consider the following boolean formula: 
\begin_inset Formula $F\equiv x_{1}\wedge(\overline{x_{1}}\vee x_{2})$
\end_inset

 .
 Formula 
\begin_inset Formula $F$
\end_inset

 is clearly satisfiable because 
\begin_inset Formula $\Psi(x_{1}\wedge(\overline{x_{1}}\vee x_{2}),\{\psi(x_{1})=\mathrm{TRUE},\psi(x_{2})=\mathrm{TRUE}\})=\mathrm{TRUE}$
\end_inset

.
 In other words, assignment 
\begin_inset Formula $x_{1}=\mathrm{TRUE}$
\end_inset

 and 
\begin_inset Formula $x_{2}=\mathrm{TRUE}$
\end_inset

 is a satisfying assignment.
\end_layout

\begin_layout Standard
There are also boolean formulas with no satisfying assignment.
 One of such formulas is shown as an example.
\end_layout

\begin_layout Example
Consider the following boolean formula: 
\begin_inset Formula $F\equiv(x_{1}\vee x_{2})\wedge(x_{1}\vee\overline{x_{2}})\wedge(\overline{x_{1}}\vee x_{2})\wedge(\overline{x_{1}}\vee\overline{x_{2}})$
\end_inset

 .
 It is easy to check that this formula is unsatisfiable because under all
 possible truth assignments it evaluates to 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
 We can brute force through all the possible assignments to verify that.
 Setting 
\begin_inset Formula $x_{1}=\mathrm{TRUE}$
\end_inset

 and 
\begin_inset Formula $x_{2}=\mathrm{TRUE}$
\end_inset

 causes 
\begin_inset Formula $(\overline{x_{1}}\vee\overline{x_{2}})$
\end_inset

 to evaluate to 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

 which makes the whole formula also 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
 Similarly, setting 
\begin_inset Formula $x_{1}=\mathrm{TRUE}$
\end_inset

 and 
\begin_inset Formula $x_{2}=\mathrm{FALSE}$
\end_inset

 causes 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(\overline{x_{1}}\vee x_{2})$
\end_inset

 to evaluate to 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $\mathrm{FALSE}$
\end_inset

 and so on.
 Careful reader may verify that every possible assignment falsifies exactly
 one of the disjunctions from which the formula is constructed.
 The whole formula is a conjunction of disjunctions and evaluates to 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

 if at least one of the disjunctions evaluates to 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
\end_layout

\begin_layout Standard
A boolean variable or its negation is also called a
\emph on
 literal
\emph default
.
 Both 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $\overline{x}$
\end_inset

 are literals.
 A disjunction of literals is called a 
\emph on
clause.
 
\emph default
For instance: 
\begin_inset Formula $(x_{1}\vee\overline{x_{2}})$
\end_inset

 and 
\begin_inset Formula $(x_{1}\vee x_{2}\vee x_{3})$
\end_inset

 are both clauses.
 We consider a special way in which we write boolean formulas as a conjunction
 of clauses
\end_layout

\begin_layout Definition
We say that a formula 
\begin_inset Formula $F$
\end_inset

 is written in 
\emph on
Conjunctive Normal Form (CNF)
\emph default
 if 
\begin_inset Formula $F$
\end_inset

 is a conjunction of clauses i.e.
 
\begin_inset Formula $F\equiv\bigwedge_{i=1}^{m}c_{i}$
\end_inset

, where each 
\begin_inset Formula $c_{i}$
\end_inset

 is a clause.
 
\end_layout

\begin_layout Standard
We provide an example of the formula written in a 
\emph on
CNF.

\emph default
 
\end_layout

\begin_layout Example
\begin_inset Formula $F\equiv(x_{1}\vee x_{2})\wedge(x_{1}\vee\overline{x_{2}})\wedge(\overline{x_{1}}\vee x_{2})\wedge(\overline{x_{1}}\vee\overline{x_{2}})$
\end_inset

 is a 
\emph on
CNF
\emph default
 formula.
 The set of clauses is 
\begin_inset Formula $\{(x_{1}\vee x_{2}),(x_{1}\vee\overline{x_{2}}),(\overline{x_{1}}\vee x_{2}),(\overline{x_{1}}\vee\overline{x_{2}})\}$
\end_inset

.
 The set of literals is 
\begin_inset Formula $\{x_{1},\overline{x_{1}},x_{2},\overline{x_{2}}\}$
\end_inset

 
\end_layout

\begin_layout Standard
We define the 
\emph on
SAT-CNF 
\emph default
problem as a special case of the 
\emph on
SAT 
\emph default
problem for which the input formulas are in 
\emph on
CNF
\emph default
.
 
\end_layout

\begin_layout Remark
Every boolean formula can be transformed into 
\emph on
CNF
\emph default
, but this transformation may require exponentially more clauses than the
 original formula has if we want to preserve the set of satisfying assignments.
 Sometimes we may consider transformations that do not preserve exact satisfying
 assignments but are still useful.
 One of such transformations is the so-called Tseytin transformation 
\begin_inset CommandInset citation
LatexCommand cite
key "Tseytin1968"

\end_inset

.
 The result of this transformation is a
\emph on
 
\emph default
formula
\emph on
 equisatisfiable
\emph default
 to the original formula (satisfiable iff the original formula is satisfiable).
 A Tseytin transformation is summarized in the following steps:
\end_layout

\begin_layout Enumerate
Generate the parsing (derivation) tree for the boolean formula 
\begin_inset Formula $F$
\end_inset

 based on a boolean formulas grammar (Definition 
\begin_inset CommandInset ref
LatexCommand ref
reference "Boolean-formula"

\end_inset

).
\end_layout

\begin_layout Enumerate
For every internal node in the generated tree, introduce a boolean variable
 
\begin_inset Formula $b$
\end_inset

 and add clause(s) assuring that it is logically equivalent to the subformula
 derived from its children.
 For instance, consider the formula 
\begin_inset Formula $F_{1}\rightarrow F_{2}\vee F_{3}$
\end_inset

 (meaning: 
\begin_inset Formula $F_{1}$
\end_inset

 is the parent, 
\begin_inset Formula $F_{2}$
\end_inset

, 
\begin_inset Formula $\vee$
\end_inset

, 
\begin_inset Formula $F_{3}$
\end_inset

 are children of 
\begin_inset Formula $F_{1}$
\end_inset

 in the derivation tree).
 Recursively applying Tseytin transformation on 
\begin_inset Formula $F_{1}$
\end_inset

 introduces variables 
\begin_inset Formula $f_{2}$
\end_inset

 for 
\begin_inset Formula $F_{2}$
\end_inset

 and 
\begin_inset Formula $f_{3}$
\end_inset

 for 
\begin_inset Formula $F_{3}$
\end_inset

.
 When introducing variable 
\begin_inset Formula $f_{1}$
\end_inset

 to represent 
\begin_inset Formula $F_{1}$
\end_inset

, we have to add the following logical equivalence constraint: 
\begin_inset Formula $f_{1}\Leftrightarrow(f_{2}\vee f_{3})$
\end_inset

 which can be written in 
\emph on
CNF
\emph default
 as: 
\begin_inset Formula $\overline{(f_{1}}\vee f_{2}\vee f_{3})\wedge(\overline{f_{2}}\vee f_{1})\wedge(\overline{f_{3}}\vee f_{1})$
\end_inset

 
\end_layout

\begin_layout Enumerate
For the root node 
\begin_inset Formula $r$
\end_inset

, we need to assure that the variable representing it is set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
 It is enough to add the single-element clause 
\begin_inset Formula $(r)$
\end_inset

 to express this constraint.
\end_layout

\begin_layout Section
The Integer Factorization Problem
\begin_inset CommandInset label
LatexCommand label
name "sec:The-Integer-Factorization"

\end_inset


\end_layout

\begin_layout Standard
In this section, we provide a brief introduction regarding the 
\emph on
Integer-Factorization 
\emph default
problem.
 Given 
\begin_inset Formula $n\in\mathbb{Z}$
\end_inset

 we ask if there are 
\begin_inset Formula $p\in\mathbb{Z}$
\end_inset

 and 
\begin_inset Formula $q\in\mathbb{Z}$
\end_inset

 such that 
\begin_inset Formula $n=pq$
\end_inset

 and 
\begin_inset Formula $1<p,q<n$
\end_inset

.
 If this is the case then we call 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 the nontrivial factors of 
\begin_inset Formula $n$
\end_inset

, and 
\begin_inset Formula $n$
\end_inset

 itself is called a composite number.
 If 
\begin_inset Formula $n$
\end_inset

 has no nontrivial factors, we call it a prime (prime number).
 For all 
\begin_inset Formula $n\geq1$
\end_inset

 there is always a prime 
\begin_inset Formula $p$
\end_inset

 such that 
\begin_inset Formula $n<p\leq2n$
\end_inset

.
 This fundamental fact is known as the Bertrand's postulate.
 One of the proofs of this fact was produced by Paul Erd
\begin_inset Formula $\H{o}$
\end_inset

s and is presented by Galvin 
\begin_inset CommandInset citation
LatexCommand cite
key "Galv2015"

\end_inset

.
 Because of Bertrand's postulate, we can be sure that there is at least
 one prime among 
\begin_inset Formula $n$
\end_inset

-bit integers.
 It is obvious that for 
\begin_inset Formula $n\geq3$
\end_inset

 there is also at least one composite among 
\begin_inset Formula $n$
\end_inset

-bit integers.
 This fact is of a special importance to us because we consider boolean
 formulas generated for 
\emph on
Integer-Factorization 
\emph default
of 
\begin_inset Formula $n$
\end_inset

-bit integers in the following chapters.
 
\end_layout

\begin_layout Standard
The 
\emph on
Integer-Factorization 
\emph default
problem is not only an interesting mathematical problem.
 It is important in public-key cryptography since one of the most popular
 cryptosystems, named RSA, is relying on the hardness of factoring integers.
 The acronym RSA is made of the initial letters of the surnames of Ron Rivest,
 Adi Shamir, and Leonard Adleman, who first publicly described the algorithm
 in 1977 
\begin_inset CommandInset citation
LatexCommand cite
key "RSA1978"

\end_inset

.
 In the RSA cryptosystem we use a big integer 
\begin_inset Formula $n$
\end_inset

, which is a composite number that can be factored into exactly two prime
 numbers 
\begin_inset Formula $n=pq$
\end_inset

, as a public key.
 Everyone can know 
\begin_inset Formula $n$
\end_inset

 and use it to encrypt a message.
 However, decrypting the message requires knowing the prime factors 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

.
 If factoring were easy, then clearly one could factor the number 
\begin_inset Formula $n$
\end_inset

 and recover 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

, breaking the whole RSA cryptosystem.
 
\end_layout

\begin_layout Standard
There is a truly brilliant algorithm that factors the integers in polynomial
 time.
 This algorithm leverages the power of a quantum computing model of computation
 and was introduced by Peter Shor 
\begin_inset CommandInset citation
LatexCommand cite
key "Shor1997"

\end_inset

.
 Over 20 years has passed since then and we are still not able to engineer
 the quantum computers that are able to endanger the RSA cryptosystem.
 Thus, we are still much better off trying classical algorithms.
\end_layout

\begin_layout Standard
We briefly give examples of classic integer-factorization algorithms.
 The simplest possible algorithm is a so-called trial division algorithm.
 In this algorithm we simply try all the odd numbers 
\begin_inset Formula $d$
\end_inset

 such that 
\begin_inset Formula $d\leq\sqrt{n}$
\end_inset

.
 If a number 
\begin_inset Formula $d$
\end_inset

 divides 
\begin_inset Formula $n$
\end_inset

 then it is a factor of 
\begin_inset Formula $n$
\end_inset

 by definition.
 We also need to account for a fact that a power of 
\begin_inset Formula $d$
\end_inset

 may divide 
\begin_inset Formula $n$
\end_inset

.
 This is simply done by dividing 
\begin_inset Formula $n$
\end_inset

 by 
\begin_inset Formula $d$
\end_inset

 multiple times till the resulting rest is not 
\begin_inset Formula $0$
\end_inset

.
 After this procedure, we are left with a list of odd factors of 
\begin_inset Formula $n$
\end_inset

.
 What remains in the process is a power of 
\begin_inset Formula $2$
\end_inset

.
 This simple method of factoring integers requires 
\begin_inset Formula $\Theta(\sqrt{n})$
\end_inset

 divisions to be performed, thus the algorithm is exponential in the number
 of bits of 
\begin_inset Formula $n$
\end_inset

.
 Another elementary approach of factoring integers is a so-called Fermat's
 factorization method.
 It is named after the famous French mathematician Pierre de Fermat.
 This simple method relies on representing 
\begin_inset Formula $n$
\end_inset

 as a difference of squares 
\begin_inset Formula $n=a^{2}-b^{2}=(a-b)(a+b)$
\end_inset

.
 If neither factor is 
\begin_inset Formula $1$
\end_inset

, then it is a proper factorization of 
\begin_inset Formula $n$
\end_inset

.
 It is crucial that each odd number can be represented as a difference of
 squares.
 To demonstrate this fact let 
\begin_inset Formula $n=lm$
\end_inset

, then
\begin_inset Formula 
\[
n=(\frac{l+m}{2})^{2}-(\frac{l-m}{2})^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $n$
\end_inset

 is odd, then necessarily 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

 are also odd, thus the fractions in parentheses are integers and we get
 a desired representation as a difference of squares.
 The task is to find 
\begin_inset Formula $a$
\end_inset

 and 
\begin_inset Formula $b$
\end_inset

 such that 
\begin_inset Formula $n=a^{2}-b^{2}$
\end_inset

.
 In a basic method we pick 
\begin_inset Formula $a=\lceil\sqrt{n}\rceil$
\end_inset

.
 If we are lucky then 
\begin_inset Formula $a^{2}-n$
\end_inset

 is a perfect square.
 In this case we can use 
\begin_inset Formula $b^{2}=a^{2}-n$
\end_inset

.
 We may need to keep on incrementing 
\begin_inset Formula $a$
\end_inset

 till we get a perfect square.
 For example, to factor 
\begin_inset Formula $n=5959$
\end_inset

, we shall start with 
\begin_inset Formula $a=\lceil\sqrt{5959}\rceil=78.$
\end_inset

 
\begin_inset Formula $78^{2}-5959=125$
\end_inset

, which is not a perfect square.
 We try with 
\begin_inset Formula $a=79$
\end_inset

.
 
\begin_inset Formula $79^{2}-5959=282$
\end_inset

, which is still not a perfect square.
 When trying 
\begin_inset Formula $a=80$
\end_inset

, we get 
\begin_inset Formula $80^{2}-5959=441=21^{2}.$
\end_inset

 Therefore, we can use 
\begin_inset Formula $a=80$
\end_inset

, 
\begin_inset Formula $b=21$
\end_inset

, which leads to the following factorization of 
\begin_inset Formula $n=5959=(80-21)(80+21)=59\cdot101$
\end_inset

.
 This basic method can be improved as demonstrated by James McKee 
\begin_inset CommandInset citation
LatexCommand cite
key "McKee1999"

\end_inset

.
 There are lots of different factoring algorithms including the Pollard's
 rho algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "Pollard1975"

\end_inset

 and the sieve algorithms, such as the general number field sieve and the
 quadratic sieve.
\end_layout

\begin_layout Section
The OWA-Winner Problem
\begin_inset CommandInset label
LatexCommand label
name "sec:The-OWA-Winner-Problem"

\end_inset


\end_layout

\begin_layout Standard
In this section, we provide a brief introduction regarding the 
\emph on
OWA
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "OWA"
description "Ordered Weighted Average"

\end_inset

-Winner
\emph default
 problem.
\begin_inset Foot
status open

\begin_layout Plain Layout
OWA stands for Ordered Weighted Average
\end_layout

\end_inset

 The 
\emph on
OWA-Winner
\emph default
 problem was originally introduced by Skowron, Faliszewski and Lang 
\begin_inset CommandInset citation
LatexCommand cite
key "FaliszOWA2016"

\end_inset

 and is related to voting and elections.
 Let us consider the following problem: There is a collection of items (e.g.,
 facultative academic courses) and a group of agents (e.g., students); each
 agent has some intrinsic utility for each of the items.
 Our goal is to pick a set of 
\begin_inset Formula $K$
\end_inset

 items that maximize the total derived utility of all the agents (i.e., in
 our example we are to pick 
\begin_inset Formula $K$
\end_inset

 facultative academic courses that we teach a group of students in the upcoming
 semester).
 The actual utility that an agent derives from a given item is only a fraction
 of its intrinsic one, and this fraction depends on how the agent ranks
 the item among the chosen, available, ones.
 There are lots of real-world problems that are related to selecting a set
 of items for a group of agents.
 Examples include voting for a parliament or deciding which laptop models
 to buy depending on the preferences of employees working in a company.
\end_layout

\begin_layout Standard
The formal setting of the 
\emph on
OWA-Winner
\emph default
 problem is presented below.
 Given a set of 
\begin_inset Formula $n$
\end_inset

 agents 
\emph on

\begin_inset Formula $N=\{1,2,...,n\}$
\end_inset

,
\emph default
 a set of 
\begin_inset Formula $m$
\end_inset

 items 
\begin_inset Formula $A=\{a_{1},a_{2},...,a_{m}\}$
\end_inset

 and an integer 
\begin_inset Formula $K$
\end_inset

 we want to select a size-
\begin_inset Formula $K$
\end_inset

 set 
\begin_inset Formula $W$
\end_inset

 of items which in some sense are the most satisfying for the agents.
 In order to measure the level of satisfaction for each agent 
\begin_inset Formula $i\in N$
\end_inset

 and for each item 
\begin_inset Formula $a_{j}\in A$
\end_inset

, we introduce an intrinsic utility 
\begin_inset Formula $u_{i,a_{j}}\geq0$
\end_inset

 that agent 
\begin_inset Formula $i$
\end_inset

 derives from 
\begin_inset Formula $a_{j}$
\end_inset

.
 Total satisfaction of agent 
\begin_inset Formula $i$
\end_inset

 derived from set 
\begin_inset Formula $W$
\end_inset

 is measured as an ordered weighted average of this agent's utilities for
 these items.
 An 
\emph on
ordered weighted average (OWA) 
\emph default
operator over 
\begin_inset Formula $K$
\end_inset

 numbers can be defined through a vector 
\begin_inset Formula $\alpha^{(K)}=\langle\alpha_{1},\alpha_{2},...,\alpha_{K}\rangle$
\end_inset

 of 
\begin_inset Formula $K$
\end_inset

 nonnegative numbers in a following way.
 Let 
\begin_inset Formula $\vec{x}=\langle x_{1},x_{2},...,x_{K}\rangle$
\end_inset

 be a vector consisting of 
\begin_inset Formula $K$
\end_inset

 numbers and let 
\begin_inset Formula $\vec{x}^{\downarrow}=\langle x_{1}^{\downarrow},x_{2}^{\downarrow},...,x_{K}^{\downarrow}\rangle$
\end_inset

 be the nonincreasing rearrangement of 
\begin_inset Formula $\vec{x}$
\end_inset

, that is, 
\begin_inset Formula $x_{i}^{\downarrow}=x_{\sigma(i)}$
\end_inset

, where 
\begin_inset Formula $\sigma$
\end_inset

 is a permutation of 
\begin_inset Formula $\{1,2,...,K\}$
\end_inset

 such that 
\begin_inset Formula $x_{\sigma(1)}\geq x_{\sigma(2)}\geq...\geq x_{\sigma(K)}$
\end_inset

.
 Then we define meaning of the OWA operator in the following way:
\begin_inset Formula 
\[
\mathrm{OWA}\alpha^{(K)}(\vec{x})=\sum_{i=1}^{K}\alpha_{i}x_{i}^{\downarrow}
\]

\end_inset

For simplicity, we will write 
\begin_inset Formula $\alpha^{(K)}(x_{1},x_{2},...,x_{K})$
\end_inset

 instead of 
\begin_inset Formula $OWA\alpha^{(K)}(x_{1},x_{2},...,x_{K})$
\end_inset

.
 Having defined what the ordered weighted operator is, we focus on formalizing
 the problem of computing 
\begin_inset Quotes eld
\end_inset

the most satisfying set of 
\begin_inset Formula $K$
\end_inset

 items
\begin_inset Quotes erd
\end_inset

 as follows.
\end_layout

\begin_layout Definition
\begin_inset CommandInset citation
LatexCommand cite
key "FaliszOWA2016"

\end_inset


\begin_inset space ~
\end_inset

In the OWA-Winner problem we are given a set 
\begin_inset Formula $N=[n]=\{1,2,...,n\}$
\end_inset

 of agents, a set 
\begin_inset Formula $A=\{a_{1},...,a_{m}\}$
\end_inset

 of items, a collection of agent’s utilities 
\begin_inset Formula $(u_{i,a_{j}}){}_{i\in[n],a_{j}\in A}$
\end_inset

, a positive integer 
\begin_inset Formula $K(K≤m)$
\end_inset

, and a 
\begin_inset Formula $K$
\end_inset

-
\begin_inset Formula $\mathrm{number}\,\mathrm{OWA}\,\alpha^{(K)}$
\end_inset

 .
 The task is to compute a subset 
\begin_inset Formula $W=\{w_{1},...,w_{K}\}$
\end_inset

 of 
\begin_inset Formula $A$
\end_inset

 such that 
\begin_inset Formula $u_{ut}^{\alpha^{(K)}}(W)=\sum_{i=1}^{n}\alpha^{(K)}(u_{i,w_{1}},...,u_{i,w_{K}})$
\end_inset

 is maximal.
\end_layout

\begin_layout Standard
The definition above can be translated into an integer linear program (
\emph on
ILP
\emph default
).
 One such translation is presented by Skowron et al.
 
\begin_inset CommandInset citation
LatexCommand cite
key "FaliszOWA2016"

\end_inset

 .
 In this thesis, we reconsider this translation and provide corrections
 to minor errors present in the original.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset citation
LatexCommand cite
key "FaliszOWA2016"

\end_inset


\begin_inset space ~
\end_inset

OWA-Winner problem can be stated as the following integer linear program:
\begin_inset Formula 
\begin{align*}
 & \mathrm{maximize}\,\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\\
 & \mathrm{subject\,to}:\\
 & (a):\sum_{i=1}^{m}y_{i}=K\\
 & (b):x_{i,j,k}\leq y_{j} & ,i\in[n];j\in[m];k\in[K]\\
 & (c):\sum_{j=1}^{m}x_{i,j,k}=1 & ,i\in[n];k\in[K]\\
 & (d):\sum_{k=1}^{K}x_{i,j,k}\leq1 & ,i\in[n];j\in[m]\\
 & (e):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (f):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (g):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We have that 
\begin_inset Formula $[n]=\{1,2,...,n\}$
\end_inset

 is the set of agents, 
\begin_inset Formula $A=\{a_{1},...,a_{m}\}$
\end_inset

 is the set of items, 
\begin_inset Formula $\alpha=\{\alpha_{1},...,\alpha_{k}\}$
\end_inset

 is the 
\emph on
OWA
\emph default
 vector, 
\begin_inset Formula $u_{i,a_{j}}$
\end_inset

is the utility that the agent 
\begin_inset Formula $i$
\end_inset

 derives from the item 
\begin_inset Formula $a_{j}.$
\end_inset


\end_layout

\begin_layout Standard
The intended meaning of the variables in this 
\emph on
ILP 
\emph default
formulation is as follows:
\end_layout

\begin_layout Standard
\begin_inset Formula $x_{i,j,k}=\begin{cases}
1 & \mathrm{for\,agent\,\mathit{i}\,item\,\mathit{a}_{j}\,is\,the\,\mathit{k}\mathrm{-}th\,most\,preferred\,from\,items\,in\,a\,solution}\\
0 & \mathrm{otherwise}
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $y_{j}=\begin{cases}
1 & \mathrm{item\,\mathit{j}\,is\,taken\,in\,a\,solution}\\
0 & \mathrm{otherwise}
\end{cases}$
\end_inset


\end_layout

\begin_layout Standard
By maximizing: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}$
\end_inset

 we maximize the total sum of weighted utilities that agents derive from
 the items.
 This is consistent with
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\emph default
the
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 problem's statement.
 Below we clarify why conditions (a)-(g) are necessary in this 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
ILP
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 formulation:
\end_layout

\begin_layout Standard
(a) - This condition states that exactly 
\begin_inset Formula $K$
\end_inset

 items are chosen in a solution.
\end_layout

\begin_layout Standard
(b) - If item 
\begin_inset Formula $a_{j}$
\end_inset

 is not chosen in a solution, then there should be no agent 
\begin_inset Formula $i$
\end_inset

 for whom this item appears on 
\begin_inset Formula $k\mathrm{-th}$
\end_inset

 position from items appearing in a solution.
 This constraint enforces that 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are mutually consistent with each other.
\end_layout

\begin_layout Standard
(c) - For agent 
\begin_inset Formula $i$
\end_inset

, there is exactly one item on the 
\begin_inset Formula $k\mathrm{-th}$
\end_inset

 most preferred place from items appearing in a solution.
\end_layout

\begin_layout Standard
(d) - For agent 
\begin_inset Formula $i$
\end_inset

 and item 
\begin_inset Formula $a_{j}$
\end_inset

, we require that agent 
\begin_inset Formula $i$
\end_inset

 views item 
\begin_inset Formula $a_{j}$
\end_inset

 on at most one position from the solution.
 Note that agent 
\begin_inset Formula $i$
\end_inset

 may not view item 
\begin_inset Formula $a_{j}$
\end_inset

 among his/her list of 
\begin_inset Formula $K$
\end_inset

 most preferred items (but still item 
\begin_inset Formula $a_{j}$
\end_inset

 might have been taken into solution).
\end_layout

\begin_layout Standard
(e) - For agent 
\begin_inset Formula $i$
\end_inset

, utility derived from item appearing on the 
\begin_inset Formula $k\mathrm{-th}$
\end_inset

 position in a solution is not smaller than the utility derived from the
 item appearing on the 
\begin_inset Formula $(k+1)\mathrm{-st}$
\end_inset

 position in the solution.
\end_layout

\begin_layout Standard
(f) - 
\begin_inset Formula $x_{i,j,k}$
\end_inset

 is a binary variable for 
\begin_inset Formula $i\in[n];j\in[m];k\in[K]$
\end_inset


\end_layout

\begin_layout Standard
(g) - 
\begin_inset Formula $y_{j}$
\end_inset

 is a binary variable for 
\begin_inset Formula $j\in[m]$
\end_inset


\end_layout

\begin_layout Standard
The theorem on the 
\emph on
ILP
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "ILP"
description "Integer Linear Programming"

\end_inset

 
\emph default
formulation of the OWA-Winner
\emph on
 
\emph default
problem will be very useful when designing a 
\emph on
SAT-CNF 
\emph default
encoding of the 
\emph on
OWA-Winner 
\emph default
problem.
\end_layout

\end_body
\end_document
