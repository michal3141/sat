#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}
 \renewcommand{\sectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsubsectionautorefname}{sec.\negthinspace}
 \renewcommand{\figureautorefname}{Fig.\negthinspace}
 \renewcommand{\tableautorefname}{Tab.\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% enables algorithmic crap
\usepackage{algorithmic}

% enables multirow editing
\usepackage{multirow}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}

% adding spacing between paragraph titles
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}%
   {1.5ex \@plus .2ex}%
   {\normalfont\normalsize\bfseries}}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage,fleqn
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Reducing Selected Computational Problems to SAT-CNF
\end_layout

\begin_layout Standard
In this chapter we present the detailed description of how to reduce both
 
\emph on
Integer Factoriazation 
\emph default
and 
\emph on
OWA-Winner 
\emph default
problems to 
\emph on
SAT-CNF.
 
\end_layout

\begin_layout Section
Reducing Integer Factorization to SAT-CNF
\end_layout

\begin_layout Standard
Since 
\emph on
Integer Factorization
\emph default
 problem belongs to the class 
\emph on
NP,
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
It is easy to verify that given 
\begin_inset Formula $n$
\end_inset

 and numbers 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 if 
\begin_inset Formula $n=pq$
\end_inset


\end_layout

\end_inset

 there is a way to reduce it to 
\emph on
SAT-CNF
\emph default
 in polynomial time.
 Arguably, the most direct way of doing so is to encode multiplication circuit
 as a 
\emph on
SAT-CNF
\emph default
 formula.
 One of such encodings is available in the work of Srebrny 
\begin_inset CommandInset citation
LatexCommand cite
key "Srebrny2004"

\end_inset

.
 In the following subsections we present descriptions of various constraints
 used in this encoding.
 The main goal of each subsection is to establish either a 
\emph on
CNF
\emph default
 encoding for a given constraint or an algorithm producing such an encoding.
\end_layout

\begin_layout Paragraph
Encoding Equality of Sequences 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{X}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and 
\begin_inset Formula $\mathbf{Y}$
\end_inset

 (
\begin_inset Formula $\mathbf{X=Y}$
\end_inset

)
\end_layout

\begin_layout Standard
To represent equality between sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 it suffices to encode 
\begin_inset Quotes eld
\end_inset

variable-wise
\begin_inset Quotes erd
\end_inset

 equality.
 Given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We define the equality of sequences in the following way
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & X=Y\iff(x_{1},x_{2},..,x_{n})=(y_{1},y_{2},..,y_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This equality constraint can be written as a conjunction of equivalences
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \bigwedge_{i=1}^{n}(x_{i}\Leftrightarrow y_{i})
\end{align*}

\end_inset

Finally, we replace equivalences with logically equivalent conjunctions
 of disjunctions to obtain
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{align*}
 & \bigwedge_{i=1}^{n}((\overline{x_{i}}\vee y_{i})\wedge(x_{i}\vee\overline{y_{i}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
(in a conjunctive normal form)
\end_layout

\begin_layout Paragraph
Encoding not Equality between Sequence and Integer 
\begin_inset Formula $\mathbf{X\ne I}$
\end_inset


\end_layout

\begin_layout Standard
This type of constraint is especially useful when we want to enforce that
 some sequence 
\begin_inset Formula $X$
\end_inset

 is 
\series bold
not
\series default
 equal given integer 
\begin_inset Formula $I$
\end_inset

.
 For example we may wish that our factor 
\begin_inset Formula $X$
\end_inset

 (represented by sequence) is not equal 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
For this to hold we need to encode 
\begin_inset Formula $X\ne1$
\end_inset

 constraint as a SAT-CNF formula (set of clauses)
\end_layout

\begin_layout Standard
\begin_inset Formula $X=\langle x_{1},x_{2},..,x_{n}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I$
\end_inset

- integer
\end_layout

\begin_layout Standard
\begin_inset Formula $X\ne I$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\bigvee_{i=1}^{n}y_{i}
\]

\end_inset

where: 
\begin_inset Formula $y_{i}=x_{i}$
\end_inset

 if 
\begin_inset Formula $i\mathrm{-th}$
\end_inset

 bit of 
\begin_inset Formula $I$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

 (If 
\begin_inset Formula $i\mathrm{-th}$
\end_inset

 bit of 
\begin_inset Formula $I$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 then 
\begin_inset Formula $y_{i}=\overline{x_{i}}$
\end_inset

)
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $I=13$
\end_inset

 and 
\begin_inset Formula $X=\langle x_{1},x_{2},x_{3},x_{4}\rangle$
\end_inset

 Constraint 
\begin_inset Formula $X\ne I$
\end_inset

 can be encoded as 
\begin_inset Formula $(\overline{x_{1}}\vee x_{2}\vee\overline{x_{3}}\vee\overline{x_{4}})$
\end_inset

 
\end_layout

\begin_layout Paragraph
Encoding Shift Equality Constraint 
\begin_inset Formula $\mathbf{Y=2^{i}X}$
\end_inset


\end_layout

\begin_layout Standard
This constraint is basically stating that after shifting 
\begin_inset Formula $X$
\end_inset

 by 
\begin_inset Formula $i$
\end_inset

 positions to the left we obtain 
\begin_inset Formula $Y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=\langle x_{1},x_{2},..,x_{n}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=\langle y_{1},y_{2},..,y_{n}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=2^{i}X$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(\bigwedge_{j=1}^{i}\overline{y_{j}})\wedge\bigwedge_{j=i+1}^{n}((y_{j}\vee\overline{x_{j-i}})\wedge(\overline{y_{j}}\vee x_{j-i}))
\]

\end_inset


\end_layout

\begin_layout Paragraph
Encoding Left Variable-wise Multiplication 
\begin_inset Formula $\mathbf{bX=Y}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $b$
\end_inset

 - boolean variable
\end_layout

\begin_layout Standard
\begin_inset Formula $X=\langle x_{1},x_{2},..,x_{n}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=\langle y_{1},y_{2},..,y_{n}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $bX=Y\iff(b\wedge x_{1},b\wedge x_{2},..,b\wedge x_{n})=(y_{1},y_{2},..,y_{n})$
\end_inset

 (meaning of left variable-wise multiplication)
\end_layout

\begin_layout Standard
\begin_inset Formula $bX=Y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((b\vee\overline{y_{i}})\wedge(x_{i}\vee\overline{y_{i}})\wedge(y_{i}\vee\overline{b}\vee\overline{x_{i}}))
\]

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Addition 
\begin_inset Formula $\mathbf{X+Y=Z}$
\end_inset


\end_layout

\begin_layout Standard
In order to encode addition constraint between sequences we need to introduce
 additional sequence 
\begin_inset Formula $C$
\end_inset

 representing carry bits.
\end_layout

\begin_layout Standard
\begin_inset Formula $X=\langle x_{0},x_{1},..,x_{n-1}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=\langle y_{0},y_{1},..y_{n-1}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Z=\langle z_{0},z_{1},..,z_{n-1}\rangle$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C=\langle c_{0},c_{1},..,c_{n}\rangle$
\end_inset

(Please note that carry sequence has length of 
\begin_inset Formula $n+1$
\end_inset

)
\end_layout

\begin_layout Standard
Addition can be depicted as follows:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{cccccc}   
\end_layout

\begin_layout Plain Layout

& $^{c_{n}}$ & $^{c_{n-1}}$ & ...
 & $^{c_{1}}$ & $^{c_{0}}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  & $x_{n-1}$ & ...
 & $x_{1}$ & $x_{0}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& + & $y_{n-1}$ & ...
 & $y_{1}$ & $y_{0}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout

&  & $z_{n-1}$ & ...
 & $z_{1}$ & $z_{0}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the whole addition to be valid we will require that 
\begin_inset Formula $c_{0}$
\end_inset

 and 
\begin_inset Formula $c_{n}$
\end_inset

 are both 
\begin_inset Formula $0$
\end_inset

 (
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

).
 
\begin_inset Formula $c_{i+1}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 (
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

) if at least two of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 are 
\begin_inset Formula $1$
\end_inset

.
 Otherwise 
\begin_inset Formula $c_{i+1}$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

.
 
\begin_inset Formula $z_{i}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 if either exactly one of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 or exactly three of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 are 
\begin_inset Formula $1$
\end_inset

.
 Otherwise 
\begin_inset Formula $z_{i}$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

.
 To encode addition constraint we need to translate all those requirements
 to CNF.
 One of such translations is presented below.
\end_layout

\begin_layout Standard
\begin_inset Formula $X+Y=Z$
\end_inset

 (with carry 
\begin_inset Formula $C$
\end_inset

):
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (\overline{c_{0}})\wedge(\overline{c_{n}})\\
 & \wedge\bigwedge_{i=1}^{n}((\overline{c_{i}}\vee x_{i-1}\vee c_{i-1})\wedge(\overline{c_{i}}\vee x_{i-1}\vee y_{i-1})\wedge(\overline{c_{i}}\vee y_{i-1}\vee c_{i-1})\\
 & \wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{c_{i-1}})\wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{y_{i-1}})\wedge(c_{i}\vee\overline{y_{i-1}}\vee\overline{c_{i-1}}))\\
 & \wedge\bigwedge_{i=0}^{n-1}((z_{i}\vee y_{i}\vee x_{i}\vee\overline{c_{i}})\wedge(z_{i}\vee y_{i}\vee\overline{x_{i}}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee x_{i}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee\overline{c_{i}})\\
 & \wedge(\overline{z_{i}}\vee y_{i}\vee x_{i}\vee c_{i})\wedge(\overline{z_{i}}\vee y_{i}\vee\overline{x_{i}}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee x_{i}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee c_{i}))
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Multiplication 
\begin_inset Formula $\mathbf{PQ=N}$
\end_inset


\end_layout

\begin_layout Standard
Formula for computing product of two numbers 
\begin_inset Formula $n=pq$
\end_inset

 can be expressed as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
pq=q_{0}p+q_{1}2p+q_{2}2^{2}p+...+q_{k-1}2^{k-1}p
\]

\end_inset

Careful reader can notice that formula above is basically a 
\series bold
sum of shift multiplications
\series default
 for which we have already shown appropriate encodings.
 We need a lot of additional variables (and sequences) to construct 
\emph on
CNF
\emph default
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\mathrm{ln}=\mathrm{length}(N)$
\end_inset

 and 
\begin_inset Formula $\mathrm{lq}=\mathrm{length}(Q)$
\end_inset


\end_layout

\begin_layout Standard
Below is a summary of additional sequences used to construct 
\emph on
CNF
\emph default
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

- array of 
\begin_inset Formula $\mathrm{lq}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{ln}$
\end_inset

 (i.e.
 
\begin_inset Formula $S=[S_{0},S_{1},..,S_{lq-1}]$
\end_inset

 and 
\begin_inset Formula $\mathrm{length}(S_{i})=\mathrm{ln}$
\end_inset

) 
\end_layout

\begin_layout Itemize
\begin_inset Formula $C$
\end_inset

- array of 
\begin_inset Formula $\mathrm{lq}-1$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{ln}+1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $M$
\end_inset

- array of 
\begin_inset Formula $\mathrm{lq}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{ln}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $R$
\end_inset

- array of 
\begin_inset Formula $\mathrm{lq}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{ln}$
\end_inset


\end_layout

\begin_layout Standard
Instead of writing the encoding down using explicit 
\emph on
CNF
\emph default
 formula we take approach of providing an algorithm (in form of pseudocode)
 representing the steps necessary to generate such an encoding: 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Generating-CNF-product"

\end_inset

 Each step represent constraint(s) that has to be added.
 Last two for loops are there just to fix some variables in 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 in order to explicitely decrease search space.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Generating 
\emph on
CNF
\emph default
 for 
\begin_inset Formula $PQ=N$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:Generating-CNF-product"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $S_0=P$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$S_{i}=2S_{i-1}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$M_{i}=Q_{i}S_{i}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $R_{0}=M_{0}$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$R_{i-1}+M_{i}=R_{i}$ // carry=$C_{i-1}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $R_{lq-1}=N$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {each pair $(i,j)$ $
\backslash
in$ $[0,1,..,ln-1] 
\backslash
times [0,1,..,lq-1]$ } 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i+j 
\backslash
geq ln$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$(
\backslash
bar{P_{i}} 
\backslash
vee 
\backslash
bar{Q_{j}})$ // to ensure that multiplication result does not have more
 bits than N}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$}
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i > 
\backslash
frac{lq-1}{2}$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$(
\backslash
bar{Q_{i}})$ // Limiting number of significant bits in Q}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Encoding Multiplication 
\begin_inset Formula $\mathbf{PQ=N,1<P<N,1<Q<N}$
\end_inset


\end_layout

\begin_layout Standard
The final step needed to reduce 
\emph on
Integer Factorization
\emph default
 to 
\emph on
SAT-CNF
\emph default
 is to enforce that both 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 represent nontrivial factors i.e.
 
\begin_inset Formula $1<P<N,1<Q<N$
\end_inset


\end_layout

\begin_layout Standard
There are multiple ways to do it, but the most straightforward is to demand:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Q\ne1
\]

\end_inset


\end_layout

\begin_layout Standard
Up to this point we have shown all steps necessary to convert arbitrary
 Integer Factorization problem instance to boolean formula in a 
\emph on
CN
\emph default
F.
 If a formula created in such fashion turns out to be 
\emph on
UNSAT
\emph default
 then we can be sure that there are no nontrivial factors to original 
\emph on
Integer Factorization
\emph default
 problem instance (number is prime).
\end_layout

\begin_layout Standard
If there is a satisfying assignment then we can recover factors by looking
 at part of the satisfying assignment that corresponds to 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Section
Reducing OWA-Winner to SAT-CNF
\end_layout

\begin_layout Standard
In this section we develop a machinery needed to reduce 
\emph on
OWA-Winner
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
In fact 
\emph on
OWA-Winner
\emph default
 is an optimization problem, so we will consider it's decision version.
\end_layout

\end_inset

 problem to 
\emph on
SAT-CNF
\emph default
.
 To do this we will consider 
\emph on
ILP
\emph default
 formulation of 
\emph on
OWA-Winner
\emph default
 problem presented in Chapter 1
\end_layout

\begin_layout Paragraph*
Encoding Inequality between Sequences 
\begin_inset Formula $\mathbf{X\leq Y}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=\langle x_{1},x_{2},..,x_{n}\rangle$
\end_inset

 - 
\begin_inset Formula $x_{1}$
\end_inset

 is the least significant digit, 
\begin_inset Formula $x_{n}$
\end_inset

 is the most significant digit
\end_layout

\begin_layout Standard
\begin_inset Formula $Y=\langle y_{1},y_{2},..,y_{n}\rangle$
\end_inset

 - 
\begin_inset Formula $y_{1}$
\end_inset

 is the least significant digit, 
\begin_inset Formula $y_{n}$
\end_inset

 is the most significant digit
\end_layout

\begin_layout Standard
\begin_inset Formula $X\leq Y\iff(x_{n}<y_{n})\vee(x_{n}=y_{n}\wedge(x_{n-1}<y_{n-1}\vee...(x_{1}=y_{1}\vee(x_{1}<y_{1}))))$
\end_inset


\end_layout

\begin_layout Standard
Below (
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

) we provide an algorithm which constructs a boolean formula for 
\begin_inset Formula $X\leq Y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.2"

\end_inset

Encoding 
\begin_inset Formula $X\leq Y$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow (
\backslash
bar{x_{1}}
\backslash
wedge y_{1})
\backslash
vee ((
\backslash
bar{x_{1}}
\backslash
vee y_{1}) 
\backslash
wedge (x_{1}
\backslash
vee 
\backslash
bar{y_{1}}))$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE{$f 
\backslash
leftarrow (
\backslash
bar{x_{i}}
\backslash
wedge y_{i})
\backslash
vee (((
\backslash
bar{x_{i}}
\backslash
vee y_{i}) 
\backslash
wedge (x_{i}
\backslash
vee 
\backslash
bar{y_{i}}))
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Formula generated using algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

 is not in 
\emph on
CNF
\emph default
.
 To convert it to 
\emph on
CNF
\emph default
 in efficient manners we take advantage of Tseytin transformation 
\begin_inset CommandInset citation
LatexCommand cite
key "Tseytin1968"

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Inequality between Sequence and Integer 
\begin_inset Formula $\mathbf{X\leq I}$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=\langle x_{1},x_{2},..,x_{n}\rangle$
\end_inset

 - 
\begin_inset Formula $x_{1}$
\end_inset

 is the least significant digit, 
\begin_inset Formula $x_{n}$
\end_inset

 is the most significant digit
\end_layout

\begin_layout Standard
\begin_inset Formula $I=\langle i_{1},i_{2},..,i_{n}\rangle$
\end_inset

 - binary encoding of integer 
\begin_inset Formula $I$
\end_inset

.
 
\begin_inset Formula $i_{1},i_{2},..,i_{n}$
\end_inset

 - bits
\end_layout

\begin_layout Standard
\begin_inset Formula $X\leq I$
\end_inset

 is a special case of 
\begin_inset Formula $X\leq Y$
\end_inset

 .
 Because of that we can obtain more efficient encoding of 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.3"

\end_inset

Encoding 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{1}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{1}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow x_{1}
\backslash
vee 
\backslash
bar{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
FOR {$j=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{j}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{j}} 
\backslash
wedge f$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{j}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{j}} 
\backslash
vee (x_{j} 
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Formula expressing 
\begin_inset Formula $X\leq I$
\end_inset

 can be generated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.3"

\end_inset

.
 We can employ Tseytin transformation to convert it to 
\emph on
CNF
\emph default
.
\end_layout

\begin_layout Paragraph*
Encoding Boolean Cardinality Constraints
\end_layout

\begin_layout Standard
By now we have all encodings necessary (encoding of arithmetic operations
 such as addition, multiplication, encoding of various types of equalities
 and inequalities) to express 
\emph on
ILP 
\emph default
as 
\emph on
SAT-CNF.
 
\emph default
In this section we will consider various boolean cardinality constraints
 and their encodings, which allow us to express some specific integer linear
 programs as boolean formulas more 
\emph on
efficiently
\emph default
 .
 We will show an efficient implementation of those constraints based on
 the work in: 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset

.
 The boolean cardinality constraints are giving bounds on how many boolean
 variables (from given set of boolean variables) are 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
 Below we define three major types of boolean cardinality constraints (at
 most 
\begin_inset Formula $k$
\end_inset

 of, at least 
\begin_inset Formula $k$
\end_inset

 of, exactly 
\begin_inset Formula $k$
\end_inset

 of)
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define at most 
\begin_inset Formula $k$
\end_inset

 of constraint 
\begin_inset Formula $_{\leq k}(X)$
\end_inset

 by demanding that at most 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset


\end_layout

\begin_layout Example
Let 
\begin_inset Formula $X=\{x_{1},x_{2},x_{3}\}$
\end_inset

 .
 At most 
\begin_inset Formula $1$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset

 constraint 
\begin_inset Formula $_{\leq1}(\{x_{1},x_{2},x_{3}\})$
\end_inset

 can be represented as a following boolean formula: 
\begin_inset Formula $(\overline{x_{1}}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(x_{1}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge x_{2}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge\overline{x_{2}}\wedge x_{3})$
\end_inset

.
 It enforces that there are no 
\begin_inset Formula $2$
\end_inset

 variables set to 
\begin_inset Formula $TRUE$
\end_inset

 at the same time.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define at least 
\begin_inset Formula $k$
\end_inset

 of constraint 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 by demanding that at least 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $TRUE$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define exactly 
\begin_inset Formula $k$
\end_inset

 of constraint 
\begin_inset Formula $_{=k}(X)$
\end_inset

 by demanding that exactly 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $TRUE$
\end_inset


\end_layout

\begin_layout Remark
Let 
\begin_inset Formula $k\in\mathbb{{N}}$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

 be a set of propositional (boolean) variables.
 Let 
\begin_inset Formula $CNF({}_{\leq k}(X))$
\end_inset

 be a CNF encoding of 
\begin_inset Formula $_{\leq k}(X)$
\end_inset

 , 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $CNF({}_{\geq k}(X))$
\end_inset

 be a 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
CNF
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 encoding of 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 and 
\begin_inset Formula $CNF({}_{=k}(X))$
\end_inset

 be a CNF encoding of 
\begin_inset Formula $_{=k}(X)$
\end_inset

.
 The following holds:
\end_layout

\begin_layout Remark
\begin_inset Formula 
\[
CNF({}_{=k}(X))=CNF({}_{\leq k}(X))\wedge CNF({}_{\geq k}(X))
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:LT-encoding"

\end_inset

Encoding 
\begin_inset Formula $LT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\leq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as follows:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (\overline{x_{1}}\vee s_{1,1})\\
 & (\overline{s_{1,j}}) & 1<j\leq k\\
 & (\overline{x_{i}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{s_{i-1,1}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,j-1}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{s_{i-1,j}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,k}}) & 1<i<n\\
 & (\overline{x_{n}}\vee\overline{s_{n-1,k}})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Proof of theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:LT-encoding"

\end_inset

 is available in 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "thm:GT-encoding"

\end_inset

Encoding 
\begin_inset Formula $GT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\geq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as follows:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (x_{1}\vee\overline{s_{1,1}})\\
 & (\overline{s_{1,j}}) & 1<j\leq k\\
 & (\overline{s_{i,j}},s_{i-1,j-1}) & 1<i\leq n,1<j\leq k\\
 & (\overline{s_{i,j}},s_{i-1,j},x_{i}) & 1<i\leq n,1<j\leq k\\
 & (\overline{s_{i,1}},s_{i-1,1},x_{i}) & 1<i\leq n\\
 & (s_{n,k})
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:GT-encoding"

\end_inset

 is simply obtained by applying the same technique used to construct 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:LT-encoding"

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Decision Version of OWA-Winner Problem
\end_layout

\begin_layout Standard
Let's state decision version of 
\emph on
OWA-Winner
\emph default
 problem based on 
\emph on
ILP
\emph default
 formulation from Chapter 1
\end_layout

\begin_layout Definition
Decision version of 
\emph on
OWA-Winner
\emph default
 problem reduces to checking feasibility of following integer linear program:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L & L\in\mathbb{{N}}\\
 & (b):\sum_{i=1}^{m}y_{i}=K\\
 & (c):x_{i,j,k}\leq y_{j} & ,i\in[n];j\in[m];k\in[K]\\
 & (d):\sum_{j=1}^{m}x_{i,j,k}=1 & ,i\in[n];k\in[K]\\
 & (e):\sum_{k=1}^{K}x_{i,j,k}\leq1 & ,i\in[n];j\in[m]\\
 & (f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Having stated what we mean by decison version of 
\emph on
OWA-Winner
\emph default
 problem we can finally present a way of encoding arbitrary 
\emph on
OWA-Winner
\emph default
 problem instances as a 
\emph on
SAT-CNF
\emph default
 formula.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-OWA-Winner-problem"

\end_inset

Encoding Decision OWA-Winner problem instances as SAT-CNF formulas
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L & L\in\mathbb{{N}}\\
 & (b):_{=K}(\{y_{j}|j\in[m]\})\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):_{=1}(\{x_{i,j,k}|j\in[m]\}) & ,i\in[n];k\in[K]\\
 & (e):_{\leq1}(\{x_{i,j,k}|k\in[K]\}) & ,i\in[n];j\in[m]\\
 & (f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We need to show that constraints (a) - (h) are expressible using 
\emph on
SAT-CNF
\emph default
 encodings constructed so far.
 (g) and (h) are clearly just declaring sets of propositional variables:
 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and therefore producing no clauses in a 
\emph on
CNF
\emph default
 encoding.
 Constraint (a) is simply an inequality between sequence constructed from
 
\series bold
sum of products
\series default
 and integer (
\begin_inset Formula $S\geq L$
\end_inset

 and 
\begin_inset Formula $S=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}$
\end_inset

) so in spite of being quite costly (in terms of number of variables and
 clauses) it is expressible in 
\emph on
SAT-CNF
\emph default
 format.
\end_layout

\begin_layout Proof
Similarly for (f) we can write 
\begin_inset Formula $S_{1}\geq S_{2}$
\end_inset

 where 
\begin_inset Formula $S_{1}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{1}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}$
\end_inset

) and 
\begin_inset Formula $S_{2}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{2}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)}$
\end_inset

) .
 (c) is a simple clause logically equivalent to: 
\begin_inset Formula $(x_{i,j,k}\Rightarrow y_{j})$
\end_inset

, which behaves as 
\begin_inset Formula $x_{i,j,k}\leq y_{j}$
\end_inset

.
 (b), (d), (e) are all boolean cardinality constraints for which we have
 already shown one efficient encoding.
\end_layout

\begin_layout Standard
(a) and (f) are the most costly constraints in the model.
 In the next section we will look at a slightly restricted version of decision
 
\emph on
OWA-Winner
\emph default
 problem.
\end_layout

\begin_layout Paragraph*
Encoding Decision Version of k-Best-OWA-Approval-Winner Problem
\end_layout

\begin_layout Standard
As we saw in the previous subsection it is possible to convert any Decision
 
\emph on
OWA-Winner
\emph default
 problem instance to 
\emph on
SAT-CNF
\emph default
 formula.
 It is prohibitevely expensive to encode constraints (a) and (f) (requiring
 lots of sequence multiplications).
 In this subsection we will present more restricted yet still computationally
 demanding version of Decision 
\emph on
OWA-Winner
\emph default
 problem.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "Decision-version-of-k-Best-OWA-Approval"

\end_inset

Decision version of 
\emph on
k-Best-OWA-Approval-Winner
\emph default
 problem is obtained from Decision version of 
\emph on
OWA-Winner
\emph default
 problem by:
\end_layout

\begin_layout Itemize
Forcing 
\begin_inset Formula $\alpha$
\end_inset

 - 
\emph on
OWA
\emph default
 vector and 
\begin_inset Formula $u$
\end_inset

 - derived utility to be binary (
\begin_inset Formula $\alpha_{i}\in\{0,1\},u_{i,a_{j}}\in\{0,1\}$
\end_inset

) 
\end_layout

\begin_layout Itemize
Removing following constraint: 
\begin_inset Formula $(f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset


\end_layout

\begin_layout Standard

\emph on
SAT-CNF
\emph default
 encoding of Decision 
\emph on
k-Best-OWA-Approval-Winner
\emph default
 problem follows:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-Decision-k-Best-OWA-Approval"

\end_inset

Encoding Decision k-Best-OWA-Approval-Winner problem instances as SAT-CNF
 formulas
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\})\\
 & (b):_{=K}(\{y_{j}|j\in[m]\})\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):_{=1}(\{x_{i,j,k}|j\in[m]\}) & ,i\in[n];k\in[K]\\
 & (e):_{\leq1}(\{x_{i,j,k}|k\in[K]\}) & ,i\in[n];j\in[m]\\
 & (f):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (g):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We remove 
\begin_inset Formula $\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset

 constraints.
 We can easily see that 
\begin_inset Formula $\alpha_{k}u_{i,a_{j}}$
\end_inset

 has to be either 0 or 1 (
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 are binary).
 This fact allows us to transform 
\begin_inset Formula $\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L$
\end_inset

 into 
\begin_inset Formula $_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesisExample"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
