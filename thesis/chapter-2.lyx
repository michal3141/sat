#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}
 \renewcommand{\sectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsubsectionautorefname}{sec.\negthinspace}
 \renewcommand{\figureautorefname}{Fig.\negthinspace}
 \renewcommand{\tableautorefname}{Tab.\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% enables algorithmic crap
\usepackage{algorithmic}

% enables multirow editing
\usepackage{multirow}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}

% adding spacing between paragraph titles
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}%
   {1.5ex \@plus .2ex}%
   {\normalfont\normalsize\bfseries}}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage,fleqn
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Reducing Selected Computational Problems to SAT-CNF
\end_layout

\begin_layout Standard
In this chapter we present the detailed description of how to reduce both
 
\emph on
Integer Factoriazation 
\emph default
and 
\emph on
OWA-Winner 
\emph default
problems to 
\emph on
SAT-CNF.
 
\end_layout

\begin_layout Section
Reducing Integer Factorization to SAT-CNF
\end_layout

\begin_layout Standard
Since 
\emph on
Integer Factorization
\emph default
 problem belongs to the class 
\emph on
NP,
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
It is easy to verify that given 
\begin_inset Formula $n$
\end_inset

 and numbers 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 if 
\begin_inset Formula $n=pq$
\end_inset


\end_layout

\end_inset

 there is a way to reduce it to 
\emph on
SAT-CNF
\emph default
 in polynomial time.
 Arguably, the most direct way of doing so is to encode multiplication circuit
 as a 
\emph on
SAT-CNF
\emph default
 formula.
 One of such encodings is available in the work of Srebrny 
\begin_inset CommandInset citation
LatexCommand cite
key "Srebrny2004"

\end_inset

.
 In the following subsections we present descriptions of various constraints
 used in this encoding.
 The main goal of each subsection is to establish either a 
\emph on
CNF
\emph default
 encoding for a given constraint or an algorithm producing such an encoding.
\end_layout

\begin_layout Paragraph
Encoding Equality of Sequences 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{X}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and 
\begin_inset Formula $\mathbf{Y}$
\end_inset

 (
\begin_inset Formula $\mathbf{X=Y}$
\end_inset

)
\end_layout

\begin_layout Standard
To represent equality between sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 it suffices to encode `variable-wise' equality.
 Given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We define the equality of sequences in the following way
\begin_inset Formula 
\begin{align*}
 & X=Y\iff(x_{1},x_{2},..,x_{n})=(y_{1},y_{2},..,y_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This equality constraint can be written as a conjunction of equivalences
\begin_inset Formula 
\begin{align*}
 & \bigwedge_{i=1}^{n}(x_{i}\Leftrightarrow y_{i})
\end{align*}

\end_inset

Finally, we replace equivalences with logically equivalent conjunctions
 of disjunctions to obtain
\begin_inset Formula 
\begin{align*}
 & \bigwedge_{i=1}^{n}((\overline{x_{i}}\vee y_{i})\wedge(x_{i}\vee\overline{y_{i}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
(in a conjunctive normal form)
\end_layout

\begin_layout Paragraph
Encoding Inequality Between a Sequence 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{X}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and a Constant 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{I}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 (
\begin_inset Formula $\mathbf{X\ne I}$
\end_inset

)
\end_layout

\begin_layout Standard
This type of constraint is especially useful when we want to enforce that
 some sequence 
\begin_inset Formula $X$
\end_inset

 is 
\series bold
not
\series default
 equal given integer 
\begin_inset Formula $I$
\end_inset

.
 For example, we may wish that our factor 
\begin_inset Formula $X$
\end_inset

 (represented by the sequence) is not equal 
\begin_inset Formula $1$
\end_inset

.
 For this to hold we need to encode 
\begin_inset Formula $X\ne1$
\end_inset

 constraint as a SAT-CNF formula (set of clauses).
 Given a sequence 
\begin_inset Formula $X$
\end_inset

 and an integer (constant) 
\begin_inset Formula $I$
\end_inset

, which is represented as a sequence of bits
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & I=\langle i_{1},i_{2},..,i_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We define the inequality 
\begin_inset Formula $X\ne I$
\end_inset

 in the following way
\begin_inset Formula 
\begin{align*}
 & X\ne I\iff(x_{1},x_{2},..,x_{n})\ne(i_{1},i_{2},..,i_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Let us introduce a sequence 
\begin_inset Formula $Y=\langle y_{1},y_{2},..,y_{n}\rangle$
\end_inset

, where 
\begin_inset Formula $y_{i}=x_{i}$
\end_inset

 if the 
\begin_inset Formula $i$
\end_inset

-th bit of 
\begin_inset Formula $I$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

 (If the 
\begin_inset Formula $i$
\end_inset

-th bit of 
\begin_inset Formula $I$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 then 
\begin_inset Formula $y_{i}=\overline{x_{i}}$
\end_inset

).
 The inequality 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $X\ne I$
\end_inset

 holds when the following clause is satisfiable 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\[
\bigvee_{i=1}^{n}y_{i}
\]

\end_inset


\end_layout

\begin_layout Example
Let 
\begin_inset Formula $I=13$
\end_inset

 and 
\begin_inset Formula $X=\langle x_{1},x_{2},x_{3},x_{4}\rangle$
\end_inset

 Constraint 
\begin_inset Formula $X\ne I$
\end_inset

 can be encoded as 
\begin_inset Formula $(\overline{x_{1}}\vee x_{2}\vee\overline{x_{3}}\vee\overline{x_{4}})$
\end_inset

 
\end_layout

\begin_layout Paragraph
Encoding Shift Equality Constraint (
\begin_inset Formula $\mathbf{Y=2^{i}X}$
\end_inset

)
\end_layout

\begin_layout Standard
We are given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The shift equality constraint is basically stating that after shifting 
\begin_inset Formula $X$
\end_inset

 by 
\begin_inset Formula $i$
\end_inset

 positions to the left we obtain 
\begin_inset Formula $Y$
\end_inset

.
 The shift by 
\begin_inset Formula $i$
\end_inset

 positions to the left can be defined in the following way 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
2^{i}X=\langle\underbrace{0,..,0}_{i},x_{1},..,x_{n-i}\rangle
\]

\end_inset


\end_layout

\begin_layout Standard
By definition of the equality between sequences we have
\begin_inset Formula 
\begin{align*}
 & Y=2^{i}X\iff(y_{1},y_{2},..,y_{n})=(\underbrace{0,..,0}_{i},x_{1},..,x_{n-i})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
This constraint is encoded in the following way
\begin_inset Formula 
\[
(\bigwedge_{j=1}^{i}\overline{y_{j}})\wedge\bigwedge_{j=i+1}^{n}(y_{j}\Leftrightarrow x_{j-i})
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, we replace equivalences with logically equivalent conjunctions
 of disjunctions to obtain
\begin_inset Formula 
\[
(\bigwedge_{j=1}^{i}\overline{y_{j}})\wedge\bigwedge_{j=i+1}^{n}((y_{j}\vee\overline{x_{j-i}})\wedge(\overline{y_{j}}\vee x_{j-i}))
\]

\end_inset


\end_layout

\begin_layout Standard
(in a conjunctive normal form)
\end_layout

\begin_layout Paragraph
Encoding Left Variable-Wise Multiplication (
\begin_inset Formula $\mathbf{bX=Y}$
\end_inset

)
\end_layout

\begin_layout Standard
We are given two sequences 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 and a boolean variable 
\begin_inset Formula $b$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
We want to encode the following equality
\begin_inset Formula 
\begin{align*}
 & bX=Y\iff(b\wedge x_{1},b\wedge x_{2},..,b\wedge x_{n})=(y_{1},y_{2},..,y_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
The condition 
\begin_inset Formula $bX=Y$
\end_inset

 is encoded in the following way
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((b\wedge x_{i})\Leftrightarrow y_{i})
\]

\end_inset


\end_layout

\begin_layout Standard
Finally, we rewrite the formula above as
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((b\vee\overline{y_{i}})\wedge(x_{i}\vee\overline{y_{i}})\wedge(y_{i}\vee\overline{b}\vee\overline{x_{i}}))
\]

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Addition (
\begin_inset Formula $\mathbf{X+Y=Z}$
\end_inset

)
\end_layout

\begin_layout Standard
We are given three sequences 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle\\
 & Z=\langle z_{1},z_{2},..,z_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In order to encode the addition of two sequences (
\begin_inset Formula $X+Y=Z$
\end_inset

), we need to introduce additional sequence 
\begin_inset Formula $C$
\end_inset

 representing carry bits
\begin_inset Formula 
\begin{align*}
 & C=\langle c_{0},c_{1},..,c_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Please note that 
\begin_inset Formula $C$
\end_inset

 has length of 
\begin_inset Formula $n+1$
\end_inset

.
 Addition can be depicted as follows
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{cccccc}   
\end_layout

\begin_layout Plain Layout

& $^{c_{n}}$ & $^{c_{n-1}}$ & ...
 & $^{c_{1}}$ & $^{c_{0}}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  & $x_{n-1}$ & ...
 & $x_{1}$ & $x_{0}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& + & $y_{n-1}$ & ...
 & $y_{1}$ & $y_{0}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout

&  & $z_{n-1}$ & ...
 & $z_{1}$ & $z_{0}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the whole addition to be valid, we require that 
\begin_inset Formula $c_{0}$
\end_inset

 and 
\begin_inset Formula $c_{n}$
\end_inset

 are both 
\begin_inset Formula $0$
\end_inset

 (
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

).
 
\begin_inset Formula $c_{i+1}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 (
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

) if at least two of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 are 
\begin_inset Formula $1$
\end_inset

.
 Otherwise 
\begin_inset Formula $c_{i+1}$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

.
 Value of 
\begin_inset Formula $z_{i}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 if either exactly one of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 or exactly three of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 are 
\begin_inset Formula $1$
\end_inset

.
 Otherwise 
\begin_inset Formula $z_{i}$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

.
 To encode such addition, we need to translate all these requirements to
 
\emph on
CNF
\emph default
.
 One of such translations is presented below.
\end_layout

\begin_layout Standard
\begin_inset Formula $X+Y=Z$
\end_inset

 (with carry 
\begin_inset Formula $C$
\end_inset

):
\begin_inset Formula 
\begin{align*}
 & (\overline{c_{0}})\wedge(\overline{c_{n}})\\
 & \wedge\bigwedge_{i=1}^{n}((\overline{c_{i}}\vee x_{i-1}\vee c_{i-1})\wedge(\overline{c_{i}}\vee x_{i-1}\vee y_{i-1})\wedge(\overline{c_{i}}\vee y_{i-1}\vee c_{i-1})\\
 & \wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{c_{i-1}})\wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{y_{i-1}})\wedge(c_{i}\vee\overline{y_{i-1}}\vee\overline{c_{i-1}}))\\
 & \wedge\bigwedge_{i=0}^{n-1}((z_{i}\vee y_{i}\vee x_{i}\vee\overline{c_{i}})\wedge(z_{i}\vee y_{i}\vee\overline{x_{i}}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee x_{i}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee\overline{c_{i}})\\
 & \wedge(\overline{z_{i}}\vee y_{i}\vee x_{i}\vee c_{i})\wedge(\overline{z_{i}}\vee y_{i}\vee\overline{x_{i}}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee x_{i}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee c_{i}))
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Multiplication (
\begin_inset Formula $\mathbf{PQ=N}$
\end_inset

)
\end_layout

\begin_layout Standard
Consider two 
\begin_inset Formula $k$
\end_inset

-bit integers 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

, which can be expressed in the binary form
\begin_inset Formula 
\begin{align*}
 & p=(p_{k}p_{k-1}\ldots p_{2}p_{1})_{2}\\
 & q=(q_{k}q_{k-1}\ldots q_{2}q_{1})_{2}
\end{align*}

\end_inset

Formula for computing the product of two numbers, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 can be expressed as
\begin_inset Formula 
\[
pq=q_{1}p+q_{2}2p+q_{3}2^{2}p+...+q_{k}2^{k-1}p
\]

\end_inset

We extend the notion of multiplication to sequences.
 Consider two sequences 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset


\begin_inset Formula 
\begin{align*}
 & P=\langle p_{1},p_{2},..,p_{n}\rangle\\
 & Q=\langle q_{1},q_{2},..,q_{n}\rangle
\end{align*}

\end_inset

The multiplication of sequences is defined as
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
PQ=q_{1}P+q_{2}2P+q_{3}2^{2}P+...+q_{k}2^{k-1}P
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
Careful reader can note that the formula above is basically a 
\series bold
sum of shift multiplications
\series default
 for which we have already shown appropriate encodings.
 We need a lot of additional variables (and sequences) to construct 
\emph on
CNF
\emph default
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

.
 Let 
\begin_inset Formula $\mathit{ln}$
\end_inset

 mean 
\begin_inset Formula $length(N)$
\end_inset

 and let 
\begin_inset Formula $\mathit{lq}$
\end_inset

 mean 
\begin_inset Formula $length(Q)$
\end_inset

.
 Below is a summary of additional sequences used to construct 
\emph on
CNF
\emph default
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

:
\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $S$
\end_inset

 is an array of 
\begin_inset Formula $\mathit{lq}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{\mathit{ln}}$
\end_inset

 (i.e.
 
\begin_inset Formula $S=[S_{0},S_{1},..,S_{lq-1}]$
\end_inset

 and 
\begin_inset Formula $\mathit{length(S_{i}})=ln$
\end_inset

)
\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $C$
\end_inset

 is an array of 
\begin_inset Formula $\mathit{lq}-1$
\end_inset

 sequences of length 
\begin_inset Formula $\mathit{ln}+1$
\end_inset


\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $M$
\end_inset

 is an array of 
\begin_inset Formula $\mathrm{\mathit{lq}}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathit{ln}$
\end_inset


\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $R$
\end_inset

 is an array of 
\begin_inset Formula $\mathrm{\mathit{lq}}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{\mathit{ln}}$
\end_inset


\end_layout

\begin_layout Standard
Instead of writing the encoding down using explicit 
\emph on
CNF
\emph default
 formula, we take the approach of providing an algorithm (in form of a pseudocod
e) representing the steps necessary to generate such an encoding.
 We start with an empty formula 
\begin_inset Formula $\epsilon$
\end_inset

 (no clauses) and then we proceed by adding clauses derived from the 
\emph on
CNF
\emph default
 encodings of various constraints.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Generating-CNF-product"

\end_inset

, in each step we extend the output formula by the clauses derived from
 the 
\emph on
CNF
\emph default
 encoding of a particular constraint.
 
\begin_inset Formula $CNF(c)$
\end_inset

 simply denotes the 
\emph on
CNF 
\emph default
encoding of a constraint 
\begin_inset Formula $c$
\end_inset

 e.g.
 
\begin_inset Formula $CNF(A=B+C)$
\end_inset

 means the CNF encoding of an addition 
\begin_inset Formula $A=B+C$
\end_inset

.
 Last two for loops are there to fix some variables in 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 in order to explicitely decrease the search space.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Generating 
\emph on
CNF
\emph default
 for 
\begin_inset Formula $PQ=N$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:Generating-CNF-product"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow 
\backslash
epsilon $
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow CNF(S_0=P) 
\backslash
wedge f$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$f 
\backslash
leftarrow CNF(S_{i}=2S_{i-1}) 
\backslash
wedge f$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$f 
\backslash
leftarrow CNF(M_{i}=Q_{i}S_{i}) 
\backslash
wedge f$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow CNF(R_{0}=M_{0}) 
\backslash
wedge f$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$f 
\backslash
leftarrow CNF(R_{i-1}+M_{i}=R_{i}) 
\backslash
wedge f$ // carry=$C_{i-1}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow CNF(R_{lq-1}=N) 
\backslash
wedge f$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {each pair $(i,j)$ $
\backslash
in$ $[0,1,..,ln-1] 
\backslash
times [0,1,..,lq-1]$ } 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i+j 
\backslash
geq ln$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow (
\backslash
bar{P_{i}} 
\backslash
vee 
\backslash
bar{Q_{j}}) 
\backslash
wedge f$ // to ensure that multiplication result does not have more bits
 than N}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$}
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i > 
\backslash
frac{lq-1}{2}$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow (
\backslash
bar{Q_{i}}) 
\backslash
wedge f$ // Limiting number of significant bits in Q}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Encoding Nontriviality (
\begin_inset Formula $\mathbf{P\ne1,Q\ne1}$
\end_inset

)
\end_layout

\begin_layout Standard
The final step needed to reduce 
\emph on
Integer Factorization
\emph default
 to 
\emph on
SAT-CNF
\emph default
 is to enforce that both 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 represent nontrivial factors, i.e., that 
\begin_inset Formula $1<P<N,1<Q<N$
\end_inset


\end_layout

\begin_layout Standard
There are multiple ways to do it, but the most straightforward is to demand:
\begin_inset Formula 
\[
Q\ne1
\]

\end_inset

Up to this point, we have shown all steps necessary to convert arbitrary
 
\emph on
Integer
\emph default
 
\emph on
Factorization
\emph default
 problem instance to boolean formula in 
\emph on
CN
\emph default
F.
 If the formula created in such fashion turns out to be unsatisfiable then
 we can be sure that there are no nontrivial factors for the original 
\emph on
Integer Factorization
\emph default
 problem instance.
 On the other hand, if there is a satisfying assignment, then we can recover
 factors by looking at the part of the satisfying assignment that corresponds
 to 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Section
Reducing OWA-Winner to SAT-CNF
\end_layout

\begin_layout Standard
In this section we develop a machinery needed to reduce the 
\emph on
OWA-Winner
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
In fact 
\emph on
OWA-Winner
\emph default
 is an optimization problem, so we will consider it's decision version.
\end_layout

\end_inset

 problem to 
\emph on
SAT-CNF
\emph default
.
 To do this, we consider the 
\emph on
ILP
\emph default
 formulation of 
\emph on
OWA-Winner
\emph default
 presented in Chapter 1
\end_layout

\begin_layout Paragraph*
Encoding Inequality between Sequences (
\begin_inset Formula $\mathbf{X\leq Y}$
\end_inset

)
\end_layout

\begin_layout Standard
We are given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset

We want to define a way of comparing 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

.
 The most natural way of doing so is to adopt the definition we use when
 compare binary expansions of integers.
 If we pretend that 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 are binary expansions of integers, we can write the following definitions
 for 
\begin_inset Formula $X\leq Y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X\leq Y\iff(x_{n}<y_{n})\vee(x_{n}=y_{n}\wedge(x_{n-1}<y_{n-1}\vee...(x_{1}=y_{1}\vee(x_{1}<y_{1}))))$
\end_inset


\end_layout

\begin_layout Standard
If the most significant digit of 
\begin_inset Formula $X$
\end_inset

 (
\begin_inset Formula $x_{n}$
\end_inset

) is smaller than the most significant digit of 
\begin_inset Formula $Y$
\end_inset

 (
\begin_inset Formula $y_{n}$
\end_inset

), then we know for sure that 
\begin_inset Formula $X\leq Y$
\end_inset

.
 If 
\begin_inset Formula $x_{n}=y_{n}$
\end_inset

 we keep comparing 
\begin_inset Formula $x_{n-1}$
\end_inset

 against 
\begin_inset Formula $y_{n-1}$
\end_inset

 and so on.
\end_layout

\begin_layout Standard
Below (
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

) we provide an algorithm which constructs a boolean formula encoding for
 
\begin_inset Formula $X\leq Y$
\end_inset

.
 We simply initialize the formula 
\begin_inset Formula $f$
\end_inset

 and in the for loop we keep extending 
\begin_inset Formula $f$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.2"

\end_inset

Encoding 
\begin_inset Formula $X\leq Y$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow (
\backslash
bar{x_{1}}
\backslash
wedge y_{1})
\backslash
vee ((
\backslash
bar{x_{1}}
\backslash
vee y_{1}) 
\backslash
wedge (x_{1}
\backslash
vee 
\backslash
bar{y_{1}}))$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE{$f 
\backslash
leftarrow (
\backslash
bar{x_{i}}
\backslash
wedge y_{i})
\backslash
vee (((
\backslash
bar{x_{i}}
\backslash
vee y_{i}) 
\backslash
wedge (x_{i}
\backslash
vee 
\backslash
bar{y_{i}}))
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The formula generated using algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

 is not in 
\emph on
CNF
\emph default
.
 To convert it to 
\emph on
CNF
\emph default
 efficiently, we take advantage of Tseytin transformation 
\begin_inset CommandInset citation
LatexCommand cite
key "Tseytin1968"

\end_inset

 (see Section 2.1)
\end_layout

\begin_layout Paragraph*
Encoding Inequality between a Sequence and a Constant (
\begin_inset Formula $\mathbf{X\leq I}$
\end_inset

 )
\end_layout

\begin_layout Standard
Given a sequence 
\begin_inset Formula $X$
\end_inset

 and an integer (constant) 
\begin_inset Formula $I$
\end_inset

, which is represented as a sequence of bits
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & I=\langle i_{1},i_{2},..,i_{n}\rangle
\end{align*}

\end_inset

We want to encode 
\begin_inset Formula $X\leq I$
\end_inset

, which is a special case of 
\begin_inset Formula $X\leq Y$
\end_inset

.
 Because of that we can obtain a more efficient encoding.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.3"

\end_inset

Encoding 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{1}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{1}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow x_{1}
\backslash
vee 
\backslash
bar{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
FOR {$j=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{j}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{j}} 
\backslash
wedge f$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{j}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{j}} 
\backslash
vee (x_{j} 
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Formula expressing 
\begin_inset Formula $X\leq I$
\end_inset

 can be generated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.3"

\end_inset

.
 We can employ Tseytin transformation to convert it to 
\emph on
CNF
\emph default
.
\end_layout

\begin_layout Paragraph*
Encoding Boolean Cardinality Constraints
\end_layout

\begin_layout Standard
By now, we have all the encodings necessary, to express the instances of
 
\emph on
ILP 
\emph default
as 
\emph on
SAT-CNF 
\emph default
instances
\emph on
.
 
\emph default
In this section we consider various boolean cardinality constraints and
 their encodings, which allow us to express some specific integer linear
 programs as boolean formulas more efficiently.
 We show an efficient implementation of those constraints based on the work
 of Sinz 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset

.
 The boolean cardinality constraints are giving bounds on how many boolean
 variables (from a given set of boolean variables) are 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
 Below we define three major types of boolean cardinality constraints (at
 most 
\begin_inset Formula $k$
\end_inset

 of, at least 
\begin_inset Formula $k$
\end_inset

 of, exactly 
\begin_inset Formula $k$
\end_inset

 of)
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define the 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{\leq k}(X)$
\end_inset

 by demanding that at most 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset


\end_layout

\begin_layout Example
Let 
\begin_inset Formula $X=\{x_{1},x_{2},x_{3}\}$
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

At most 
\begin_inset Formula $1$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{\leq1}(\{x_{1},x_{2},x_{3}\})$
\end_inset

 can be represented as the following boolean formula: 
\begin_inset Formula $(\overline{x_{1}}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(x_{1}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge x_{2}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge\overline{x_{2}}\wedge x_{3})$
\end_inset

.
 It enforces that there are no 
\begin_inset Formula $2$
\end_inset

 variables set to 
\begin_inset Formula $TRUE$
\end_inset

 at the same time.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 by demanding that at least 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define 
\begin_inset Quotes eld
\end_inset

exactly 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{=k}(X)$
\end_inset

 by demanding that exactly 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset


\end_layout

\begin_layout Remark
Let 
\begin_inset Formula $k$
\end_inset

 be an integer and let 
\begin_inset Formula $X$
\end_inset

 be a set of propositional (boolean) variables.
 The 
\begin_inset Quotes eld
\end_inset

exactly 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be encoded as a conjunction of the 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In the work of Sinz 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset

 the efficient encodings of 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 were given.
 These encodings work by introducing a set of additional variables 
\begin_inset Formula $s$
\end_inset

.
 Below we state the theorem that allows us to encode 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 efficiently.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:LT-encoding"

\end_inset

Encoding 
\begin_inset Formula $LT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\leq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as follows:
\begin_inset Formula 
\begin{align*}
 & (\overline{x_{1}}\vee s_{1,1})\\
 & (\overline{s_{1,j}}) & 1<j\leq k\\
 & (\overline{x_{i}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{s_{i-1,1}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,j-1}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{s_{i-1,j}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,k}}) & 1<i<n\\
 & (\overline{x_{n}}\vee\overline{s_{n-1,k}})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In the theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:LT-encoding"

\end_inset

 the variable 
\begin_inset Formula $s_{i,j}$
\end_inset

 asserts that among 
\begin_inset Formula $i$
\end_inset

 variables 
\begin_inset Formula $\{x_{1},x_{2},..,x_{i}\}$
\end_inset

 at most 
\begin_inset Formula $j$
\end_inset

 variables are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
 Below we state the corollary that allows us to encode 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 efficiently.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "thm:GT-encoding"

\end_inset

 Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}.$
\end_inset

 Encoding 
\begin_inset Formula $GT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as a 
\begin_inset Formula $LT_{SEQ}^{n,n-k}$
\end_inset

 encoding with all variables from 
\begin_inset Formula $X$
\end_inset

 negated.
\end_layout

\begin_layout Proof
Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:GT-encoding"

\end_inset

 is simply obtained by using the fact that the condition 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 variables are 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

 is the same as 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $n-k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 variables are 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
 The variable 
\begin_inset Formula $s_{i,j}$
\end_inset

 asserts that among 
\begin_inset Formula $i$
\end_inset

 variables 
\begin_inset Formula $\{x_{1},x_{2},..,x_{i}\}$
\end_inset

 at most 
\begin_inset Formula $j$
\end_inset

 variables are set to 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
 We need to negate all the occurrences of 
\begin_inset Formula $x_{j}$
\end_inset

 variables, because we are only counting variables set to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathrm{FALSE}$
\end_inset

 in this case.
\end_layout

\begin_layout Paragraph*
Encoding Decision Version of OWA-Winner Problem
\end_layout

\begin_layout Standard
Let us state the decision version of 
\emph on
OWA-Winner
\emph default
 problem based on the 
\emph on
ILP
\emph default
 formulation from Chapter 1.
 Decision version of 
\emph on
OWA-Winner
\emph default
 problem reduces to checking feasibility of following integer linear program:
\begin_inset Formula 
\begin{align*}
 & (a):\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L & L\in\mathbb{{N}}\\
 & (b):\sum_{i=1}^{m}y_{i}=K\\
 & (c):x_{i,j,k}\leq y_{j} & ,i\in[n];j\in[m];k\in[K]\\
 & (d):\sum_{j=1}^{m}x_{i,j,k}=1 & ,i\in[n];k\in[K]\\
 & (e):\sum_{k=1}^{K}x_{i,j,k}\leq1 & ,i\in[n];j\in[m]\\
 & (f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset

Having stated what we mean by the decison version of 
\emph on
OWA-Winner
\emph default
 problem, we can finally present a way of encoding arbitrary 
\emph on
OWA-Winner
\emph default
 problem instances as a 
\emph on
SAT-CNF
\emph default
 formula.
 
\begin_inset Formula $CNF(c)$
\end_inset

 simply denotes the 
\emph on
CNF 
\emph default
encoding of a constraint 
\begin_inset Formula $c$
\end_inset

 e.g.
 
\begin_inset Formula $CNF(A=B+C)$
\end_inset

 means the CNF encoding of an addition 
\begin_inset Formula $A=B+C$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-OWA-Winner-problem"

\end_inset

Decision OWA-Winner problem instances can be encoded as SAT-CNF formulas
 in the following way:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):CNF(\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L) & L\in\mathbb{{N}}\\
 & (b):CNF(_{=K}(\{y_{j}|j\in[m]\}))\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):CNF(_{=1}(\{x_{i,j,k}|j\in[m]\})) & ,i\in[n];k\in[K]\\
 & (e):CNF(_{\leq1}(\{x_{i,j,k}|k\in[K]\})) & ,i\in[n];j\in[m]\\
 & (f):CNF(\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)}) & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We need to show that constraints (a) - (h) are expressible using 
\emph on
SAT-CNF
\emph default
 encodings constructed so far.
 Constraints (g) and (h) are clearly just declaring sets of propositional
 variables: 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and therefore produce no clauses in a 
\emph on
CNF
\emph default
 encoding.
 Constraint (a) is simply an inequality between sequence constructed from
 sum of products and integer (
\begin_inset Formula $S\geq L$
\end_inset

 and 
\begin_inset Formula $S=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}$
\end_inset

).
 So, while being quite costly (in terms of number of variables and clauses)
 it is expressible in the 
\emph on
SAT-CNF
\emph default
 format.
\end_layout

\begin_layout Proof
Similarly, for constraint (f) we can write 
\begin_inset Formula $S_{1}\geq S_{2}$
\end_inset

 where 
\begin_inset Formula $S_{1}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{1}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}$
\end_inset

) and 
\begin_inset Formula $S_{2}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{2}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)}$
\end_inset

).
 Constraint (c) is a simple clause logically equivalent to: 
\begin_inset Formula $(x_{i,j,k}\Rightarrow y_{j})$
\end_inset

, which behaves alike 
\begin_inset Formula $x_{i,j,k}\leq y_{j}$
\end_inset

.
 Constraints (b), (d) and (e) are all boolean cardinality constraints for
 which we have already shown efficient encodings.
\end_layout

\begin_layout Standard
Constraints (a) and (f) are the most costly elements in the model.
 In the next section we will look at somewhat restricted version of decision
 
\emph on
OWA-Winner
\emph default
 problem in which these constraints are simplified.
\end_layout

\begin_layout Paragraph*
Encoding Decision Version of k-Best-OWA-Approval-Winner Problem
\end_layout

\begin_layout Standard
As we saw in the previous subsection, it is possible to convert any 
\emph on
Decision
\emph default
 
\emph on
OWA-Winner
\emph default
 problem instance to a
\emph on
 SAT-CNF
\emph default
 formula.
 It is prohibitevely expensive to encode constraints (a) and (f) from theorem
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Encoding-OWA-Winner-problem"

\end_inset

 (requiring lots of sequence multiplications).
 In this subsection we will present more restricted yet still computationally
 demanding version of Decision 
\emph on
OWA-Winner
\emph default
 problem.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "Decision-version-of-k-Best-OWA-Approval"

\end_inset

Decision version of 
\emph on
k-Best-OWA-Approval-Winner
\emph default
 problem is obtained from Decision version of 
\emph on
OWA-Winner
\emph default
 problem by:
\end_layout

\begin_layout Itemize
Requiring an OWA vector 
\begin_inset Formula $\alpha$
\end_inset

 and a derived utility 
\begin_inset Formula $u$
\end_inset

 to be binary (
\begin_inset Formula $\alpha_{i}\in\{0,1\},u_{i,a_{j}}\in\{0,1\}$
\end_inset

) 
\end_layout

\begin_layout Itemize
Removing the following constraint: 
\begin_inset Formula $(f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset

, which basically is not needed when 
\begin_inset Formula $\alpha$
\end_inset

 is non-increasing.
\end_layout

\begin_layout Standard

\emph on
SAT-CNF
\emph default
 encoding of Decision 
\emph on
k-Best-OWA-Approval-Winner
\emph default
 problem follows:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-Decision-k-Best-OWA-Approval"

\end_inset

Encoding Decision k-Best-OWA-Approval-Winner problem instances as SAT-CNF
 formulas
\begin_inset Formula 
\begin{align*}
 & (a):CNF(_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\}))\\
 & (b):CNF(_{=K}(\{y_{j}|j\in[m]\}))\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):CNF(_{=1}(\{x_{i,j,k}|j\in[m]\})) & ,i\in[n];k\in[K]\\
 & (e):CNF(_{\leq1}(\{x_{i,j,k}|k\in[K]\})) & ,i\in[n];j\in[m]\\
 & (f):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (g):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We remove 
\begin_inset Formula $\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset

 constraints.
 We can easily see that 
\begin_inset Formula $\alpha_{k}u_{i,a_{j}}$
\end_inset

 has to be either 0 or 1 (
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 are binary).
 This fact allows us to transform 
\begin_inset Formula $\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L$
\end_inset

 into 
\begin_inset Formula $_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesisExample"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
