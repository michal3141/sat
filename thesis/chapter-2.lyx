#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}
 \renewcommand{\chapterautorefname}{\negthinspace}
 \renewcommand{\sectionautorefname}{\negthinspace}
 \renewcommand{\subsectionautorefname}{\negthinspace}
 \renewcommand{\subsubsectionautorefname}{\negthinspace}
 \renewcommand{\figureautorefname}{\negthinspace}
 \renewcommand{\tableautorefname}{\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% enables algorithmic crap
\usepackage{algorithmic}

% enables multirow editing
\usepackage{multirow}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}

% adding spacing between paragraph titles
\renewcommand\paragraph{\@startsection{paragraph}{4}{\z@}%
   {-3.25ex\@plus -1ex \@minus -.2ex}%
   {1.5ex \@plus .2ex}%
   {\normalfont\normalsize\bfseries}}

\allowdisplaybreaks
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage,fleqn
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams-bytype
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Reducing Selected Computational Problems to SAT-CNF
\begin_inset CommandInset label
LatexCommand label
name "chap:Reducing-Selected-Computational"

\end_inset


\end_layout

\begin_layout Standard
In this chapter, we present the detailed description of how to reduce both
 the 
\emph on
Integer-Factoriazation 
\emph default
and 
\emph on
OWA-Winner 
\emph default
problems to 
\emph on
SAT-CNF.
 
\emph default
We first start by defining notions used to express boolean constraints.
\end_layout

\begin_layout Section
Basic Notions and Definitions Used to Express Boolean Constraints
\begin_inset CommandInset label
LatexCommand label
name "sec:Basic-Notions-and"

\end_inset


\end_layout

\begin_layout Standard
Below we introduce vocabulary used in the following sections to describe
 various boolean constraints.
 Most of the terms should be familiar and self-explanatory.
 We start by defining the notion of a 
\emph on
boolean variable.
\end_layout

\begin_layout Definition

\emph on
Boolean variable
\series bold
\emph default
 
\begin_inset Formula $x$
\end_inset

 
\series default
is a variable taking values from 
\begin_inset Formula $\{0,1\}$
\end_inset

 (being either FALSE or TRUE)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Standard
Performing operations on individual boolean variables is quite cumbersome
 and sometimes we want to group a bunch of boolean variables into one collection.
 Formally we will call such collections 
\emph on
sequences.
\end_layout

\begin_layout Definition

\emph on
Sequence (of boolean variables)
\emph default
 
\begin_inset Formula $\langle x_{1},x_{2},x_{3},..,x_{n}\rangle$
\end_inset

 is an ordered collection of boolean variables of a fixed size.
 The length of a sequence is a number of boolean variables associated with
 a sequence.
 It is denoted as 
\begin_inset Formula $\mathrm{length}(\langle x_{1},x_{2},..,x_{n}\rangle)=n$
\end_inset


\end_layout

\begin_layout Standard
Sequences of length 
\begin_inset Formula $n$
\end_inset

 can be used to represent 
\begin_inset Formula $n$
\end_inset

-bit integers.
 Each variable in a sequence is representing exactly one bit.
 
\end_layout

\begin_layout Remark
When using sequence 
\begin_inset Formula $X=\langle x_{1},x_{2},..,x_{n}\rangle$
\end_inset

 to represent integers, we use the convention that 
\begin_inset Formula $x_{1}$
\end_inset

 corresponds to the least significant bit and 
\begin_inset Formula $x_{n}$
\end_inset

 corresponds to the most significant bit.
\end_layout

\begin_layout Section
Reducing Integer Factorization to SAT-CNF
\begin_inset CommandInset label
LatexCommand label
name "sec:Reducing-Integer-Factorization"

\end_inset


\end_layout

\begin_layout Standard
Since the 
\emph on
Integer-Factorization
\emph default
 problem belongs to the class 
\emph on
NP,
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
It is easy to verify that given 
\begin_inset Formula $n$
\end_inset

 and numbers 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 if 
\begin_inset Formula $n=pq$
\end_inset


\end_layout

\end_inset

 there is a way to reduce it to 
\emph on
SAT-CNF
\emph default
 in polynomial time.
 Arguably, the most direct way of doing so is to encode multiplication circuit
 as a 
\emph on
SAT-CNF
\emph default
 formula.
 One of such encodings is available in the work of Srebrny 
\begin_inset CommandInset citation
LatexCommand cite
key "Srebrny2004"

\end_inset

.
 In the following subsections, we present descriptions of various constraints
 used in this encoding.
 The main goal of each subsection is to establish either a 
\emph on
CNF
\emph default
 encoding for a given constraint or an algorithm producing such an encoding.
\end_layout

\begin_layout Paragraph
Encoding Equality of Sequences 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{X}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and 
\begin_inset Formula $\mathbf{Y}$
\end_inset

 (
\begin_inset Formula $\mathbf{X=Y}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

To represent equality between sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 it suffices to encode `variable-wise' equality.
 Given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We define the equality of sequences in the following way
\begin_inset Formula 
\begin{align*}
 & X=Y\iff(x_{1},x_{2},..,x_{n})=(y_{1},y_{2},..,y_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

This equality constraint can be written as a conjunction of equivalences
\begin_inset Formula 
\begin{align*}
 & \bigwedge_{i=1}^{n}(x_{i}\Leftrightarrow y_{i})
\end{align*}

\end_inset

Finally, we replace equivalences with logically equivalent conjunctions
 of disjunctions to obtain
\begin_inset Formula 
\begin{align*}
 & \bigwedge_{i=1}^{n}((\overline{x_{i}}\vee y_{i})\wedge(x_{i}\vee\overline{y_{i}}))
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

(in a conjunctive normal form)
\end_layout

\begin_layout Paragraph
Encoding Inequality Between a Sequence 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{X}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and a Constant 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathbf{I}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 (
\begin_inset Formula $\mathbf{X\ne I}$
\end_inset

)
\end_layout

\begin_layout Standard
This type of constraint is especially useful when we want to enforce that
 some sequence 
\begin_inset Formula $X$
\end_inset

 is 
\series bold
not
\series default
 equal to a given integer 
\begin_inset Formula $I$
\end_inset

.
 For example, we may wish that our factor 
\begin_inset Formula $X$
\end_inset

 (represented by the sequence) is not equal to 
\begin_inset Formula $1$
\end_inset

.
 For this to hold we need to encode 
\begin_inset Formula $X\ne1$
\end_inset

 constraint as a 
\emph on
SAT-CNF
\emph default
 formula (set of clauses).
 Given a sequence 
\begin_inset Formula $X$
\end_inset

 and an integer (constant) 
\begin_inset Formula $I$
\end_inset

, which is represented as a sequence of bits
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & I=\langle i_{1},i_{2},..,i_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We define the inequality 
\begin_inset Formula $X\ne I$
\end_inset

 in the following way
\begin_inset Formula 
\begin{align*}
 & X\ne I\iff(x_{1},x_{2},..,x_{n})\ne(i_{1},i_{2},..,i_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I$
\end_inset

 is a sequence of bits and 
\begin_inset Formula $X$
\end_inset

 is a sequence of boolean variables.
 Therefore, these objects cannot be directly compared.
 We introduce an auxiliary sequence 
\begin_inset Formula $Y=\langle y_{1},y_{2},..,y_{n}\rangle$
\end_inset

, where 
\begin_inset Formula $y_{j}=x_{j}$
\end_inset

 if the 
\begin_inset Formula $j$
\end_inset

-th bit of 
\begin_inset Formula $I$
\end_inset

 (
\begin_inset Formula $i_{j}$
\end_inset

) is 
\begin_inset Formula $0$
\end_inset

 (If the 
\begin_inset Formula $j$
\end_inset

-th bit of 
\begin_inset Formula $I$
\end_inset

 (
\begin_inset Formula $i_{j}$
\end_inset

) is 
\begin_inset Formula $1$
\end_inset

 then 
\begin_inset Formula $y_{j}=\overline{x_{j}}$
\end_inset

).
 The crucial observation is that setting 
\begin_inset Formula $y_{j}=0$
\end_inset

 enforces 
\begin_inset Formula $x_{j}=i_{j}$
\end_inset

.
 This is exactly what we wrote when defining 
\begin_inset Formula $Y$
\end_inset

.
 If there exists 
\begin_inset Formula $j$
\end_inset

 such that 
\begin_inset Formula $y_{j}=1$
\end_inset

 then 
\begin_inset Formula $x_{j}\neq i_{j}$
\end_inset

 and as a consequence 
\begin_inset Formula $X\neq I$
\end_inset

.
 We can encode this existential condition as a boolean formula 
\begin_inset Formula 
\[
\bigvee_{i=1}^{n}y_{i}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

To better illustrate the constraint introduced above we examine an example.
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $I=13=1\cdot2^{0}+0\cdot2^{1}+1\cdot2^{2}+1\cdot2^{3}=\langle1,0,1,1\rangle$
\end_inset

 and 
\begin_inset Formula $X=\langle x_{1},x_{2},x_{3},x_{4}\rangle$
\end_inset

.
 Constraint 
\begin_inset Formula $X\ne I$
\end_inset

 can be encoded as 
\begin_inset Formula $(\overline{x_{1}}\vee x_{2}\vee\overline{x_{3}}\vee\overline{x_{4}})$
\end_inset

.
 The only way to make 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(\overline{x_{1}}\vee x_{2}\vee\overline{x_{3}}\vee\overline{x_{4}})$
\end_inset

 evaluate to 
\begin_inset Formula $0$
\end_inset

 is to set 
\begin_inset Formula $x_{1}=1$
\end_inset

, 
\begin_inset Formula $x_{2}=0$
\end_inset

, 
\begin_inset Formula $x_{3}=1$
\end_inset

, 
\begin_inset Formula $x_{4}=1$
\end_inset

 and this is the only assignment that leads to 
\begin_inset Formula $X=I$
\end_inset

.
 A satisfying assignment to 
\begin_inset Formula $(\overline{x_{1}}\vee x_{2}\vee\overline{x_{3}}\vee\overline{x_{4}})$
\end_inset

 leads to 
\begin_inset Formula $X\neq I$
\end_inset

, which is what we wanted.
\end_layout

\begin_layout Paragraph
Encoding Shift Equality Constraint (
\begin_inset Formula $\mathbf{Y=2^{i}X}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We are given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset


\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

The shift equality constraint is basically stating that after shifting 
\begin_inset Formula $X$
\end_inset

 by 
\begin_inset Formula $i$
\end_inset

 positions to the left we obtain 
\begin_inset Formula $Y$
\end_inset

.
 The shift by 
\begin_inset Formula $i$
\end_inset

 positions to the left can be defined in the following way: 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
2^{i}X=\langle\underbrace{0,..,0}_{i},x_{1},..,x_{n-i}\rangle
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

By definition of the equality between sequences we have:
\begin_inset Formula 
\begin{align*}
 & Y=2^{i}X\iff(y_{1},y_{2},..,y_{n})=(\underbrace{0,..,0}_{i},x_{1},..,x_{n-i})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

This constraint is encoded in the following way:
\begin_inset Formula 
\[
(\bigwedge_{j=1}^{i}\overline{y_{j}})\wedge\bigwedge_{j=i+1}^{n}(y_{j}\Leftrightarrow x_{j-i})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Finally, we replace equivalences with logically equivalent conjunctions
 of disjunctions to obtain:
\begin_inset Formula 
\[
(\bigwedge_{j=1}^{i}\overline{y_{j}})\wedge\bigwedge_{j=i+1}^{n}((y_{j}\vee\overline{x_{j-i}})\wedge(\overline{y_{j}}\vee x_{j-i}))
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

(in a conjunctive normal form)
\end_layout

\begin_layout Paragraph
Encoding Left Variable-Wise Multiplication (
\begin_inset Formula $\mathbf{bX=Y}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We are given two sequences 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 and a boolean variable 
\begin_inset Formula $b$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We want to encode the following equality:
\begin_inset Formula 
\begin{align*}
 & bX=Y\iff(b\wedge x_{1},b\wedge x_{2},..,b\wedge x_{n})=(y_{1},y_{2},..,y_{n})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

The condition 
\begin_inset Formula $bX=Y$
\end_inset

 is encoded in the following way:
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((b\wedge x_{i})\Leftrightarrow y_{i})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Finally, we rewrite the formula above as:
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((b\vee\overline{y_{i}})\wedge(x_{i}\vee\overline{y_{i}})\wedge(y_{i}\vee\overline{b}\vee\overline{x_{i}}))
\]

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Addition (
\begin_inset Formula $\mathbf{X+Y=Z}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We are given three sequences 
\begin_inset Formula $X$
\end_inset

, 
\begin_inset Formula $Y$
\end_inset

 and 
\begin_inset Formula $Z$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle\\
 & Z=\langle z_{1},z_{2},..,z_{n}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

In order to encode the addition of two sequences (
\begin_inset Formula $X+Y=Z$
\end_inset

), we need to introduce an additional sequence 
\begin_inset Formula $C$
\end_inset

 representing carry bits:
\begin_inset Formula 
\begin{align*}
 & C=\langle c_{1},c_{2},..,c_{n+1}\rangle
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Please note that 
\begin_inset Formula $C$
\end_inset

 has length of 
\begin_inset Formula $n+1$
\end_inset

.
 Addition can be depicted as follows
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{cccccc}   
\end_layout

\begin_layout Plain Layout

& $^{c_{n+1}}$ & $^{c_{n}}$ & ...
 & $^{c_{2}}$ & $^{c_{1}}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

&  & $x_{n}$ & ...
 & $x_{2}$ & $x_{1}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

& + & $y_{n}$ & ...
 & $y_{2}$ & $y_{1}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline   
\end_layout

\begin_layout Plain Layout

&  & $z_{n}$ & ...
 & $z_{2}$ & $z_{1}$ 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the whole addition to be valid, we require that 
\begin_inset Formula $c_{1}$
\end_inset

 and 
\begin_inset Formula $c_{n+1}$
\end_inset

 are both 
\begin_inset Formula $0$
\end_inset

 (
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

), and 
\begin_inset Formula $c_{i}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 (
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

) if at least two of 
\begin_inset Formula $\{x_{i-1},y_{i-1},c_{i-1}\}$
\end_inset

 are 
\begin_inset Formula $1$
\end_inset

.
 This enforces the following conditions: 
\begin_inset Formula $(x_{i-1}\wedge y_{i-1})\Rightarrow c_{i}$
\end_inset

, 
\begin_inset Formula $(x_{i-1}\wedge c_{i-1})\Rightarrow c_{i}$
\end_inset

, 
\begin_inset Formula $(y_{i-1}\wedge c_{i-1})\Rightarrow c_{i}$
\end_inset

.
 We can also write these conditions by transforming the implication into
 the logical disjunction using the logical tautology 
\begin_inset Formula $(p\Rightarrow q)\iff(\overline{p}\vee q)$
\end_inset

.
 We obtain 
\begin_inset Formula $(c_{i}\vee\overline{x_{i-1}}\vee\overline{c_{i-1}})\wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{y_{i-1}})\wedge(c_{i}\vee\overline{y_{i-1}}\vee\overline{c_{i-1}})$
\end_inset

.
 We can also conclude that if at least two of 
\begin_inset Formula $\{x_{i-1},y_{i-1},c_{i-1}\}$
\end_inset

 are 
\begin_inset Formula $0$
\end_inset

 then 
\begin_inset Formula $c_{i+1}$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

.
 The way of converting this constraint into 
\emph on
SAT-CNF 
\emph default
formula works as above and yields 
\begin_inset Formula $(\overline{c_{i}}\vee x_{i-1}\vee c_{i-1})\wedge(\overline{c_{i}}\vee x_{i-1}\vee y_{i-1})\wedge(\overline{c_{i}}\vee y_{i-1}\vee c_{i-1})$
\end_inset

.
 The value of 
\begin_inset Formula $z_{i}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 if either exactly one of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 or exactly three of 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 are 
\begin_inset Formula $1$
\end_inset

, which enforces the following clauses: 
\begin_inset Formula $(x_{i}\wedge\overline{y_{i}}\wedge\overline{c_{i}})\Rightarrow z_{i}$
\end_inset

, 
\begin_inset Formula $(\overline{x_{i}}\wedge y_{i}\wedge\overline{c_{i}})\Rightarrow z_{i}$
\end_inset

, 
\begin_inset Formula $(\overline{x_{i}}\wedge\overline{y_{i}}\wedge c_{i})\Rightarrow z_{i}$
\end_inset

, 
\begin_inset Formula $(x_{i}\wedge y_{i}\wedge c_{i})\Rightarrow z_{i}$
\end_inset

.
 It is easy to verify that these clauses can be converted by the rules of
 logic into 
\begin_inset Formula $(z_{i}\vee y_{i}\vee x_{i}\vee\overline{c_{i}})\wedge(z_{i}\vee y_{i}\vee\overline{x_{i}}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee x_{i}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee\overline{c_{i}})$
\end_inset

.
 The value of 
\begin_inset Formula $z_{i}$
\end_inset

 is 0 if either all 
\begin_inset Formula $\{x_{i},y_{i},c_{i}\}$
\end_inset

 are 0 or exactly two of them are 
\begin_inset Formula $1$
\end_inset

.
 By following the same procedure of encoding this constraint as above, we
 obtain 
\begin_inset Formula $(\overline{z_{i}}\vee y_{i}\vee x_{i}\vee c_{i})\wedge(\overline{z_{i}}\vee y_{i}\vee\overline{x_{i}}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee x_{i}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee c_{i})$
\end_inset

.
 All the conditions we have already discussed are necessary and sufficient
 conditions to get a valid addition of boolean sequences encoded.
 Careful reader may want to verify himself if this is really the case.
 We give a boolean formula representing addition below.
\end_layout

\begin_layout Standard
\begin_inset Formula $X+Y=Z$
\end_inset

 (with carry 
\begin_inset Formula $C$
\end_inset

):
\begin_inset Formula 
\begin{align*}
 & (\overline{c_{1}})\wedge(\overline{c_{n+1}})\\
 & \wedge\bigwedge_{i=2}^{n+1}((\overline{c_{i}}\vee x_{i-1}\vee c_{i-1})\wedge(\overline{c_{i}}\vee x_{i-1}\vee y_{i-1})\wedge(\overline{c_{i}}\vee y_{i-1}\vee c_{i-1})\\
 & \wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{c_{i-1}})\wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{y_{i-1}})\wedge(c_{i}\vee\overline{y_{i-1}}\vee\overline{c_{i-1}}))\\
 & \wedge\bigwedge_{i=1}^{n}((z_{i}\vee y_{i}\vee x_{i}\vee\overline{c_{i}})\wedge(z_{i}\vee y_{i}\vee\overline{x_{i}}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee x_{i}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee\overline{c_{i}})\\
 & \wedge(\overline{z_{i}}\vee y_{i}\vee x_{i}\vee c_{i})\wedge(\overline{z_{i}}\vee y_{i}\vee\overline{x_{i}}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee x_{i}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee c_{i}))
\end{align*}

\end_inset


\end_layout

\begin_layout Paragraph*
Encoding Multiplication (
\begin_inset Formula $\mathbf{PQ=N}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Consider two 
\begin_inset Formula $k$
\end_inset

-bit integers 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

, which can be expressed in the binary form
\begin_inset Formula 
\begin{align*}
 & p=(p_{k}p_{k-1}\ldots p_{2}p_{1})_{2}\\
 & q=(q_{k}q_{k-1}\ldots q_{2}q_{1})_{2}
\end{align*}

\end_inset

Formula for computing the product of two numbers, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 can be expressed as
\begin_inset Formula 
\[
pq=q_{1}p+q_{2}2p+q_{3}2^{2}p+...+q_{k}2^{k-1}p
\]

\end_inset

We extend the notion of multiplication to the sequences of boolean variables.
 Consider two sequences 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & P=\langle p_{1},p_{2},..,p_{n}\rangle\\
 & Q=\langle q_{1},q_{2},..,q_{n}\rangle
\end{align*}

\end_inset

The multiplication of sequences is defined as:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
PQ=q_{1}P+q_{2}2P+q_{3}2^{2}P+...+q_{k}2^{k-1}P
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
Careful reader can note that the formula above is basically a 
\series bold
sum of shift multiplications
\series default
 for which we have already shown appropriate encodings.
 We need a lot of additional variables (and sequences) to construct 
\emph on
CNF
\emph default
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

.
 Let 
\begin_inset Formula $\mathit{ln}$
\end_inset

 mean 
\begin_inset Formula $length(N)$
\end_inset

 and let 
\begin_inset Formula $\mathit{lq}$
\end_inset

 mean 
\begin_inset Formula $length(Q)$
\end_inset

.
 Below is a summary of additional sequences used to construct 
\emph on
CNF
\emph default
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

:
\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $S$
\end_inset

 is an array of 
\begin_inset Formula $\mathit{lq}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{\mathit{ln}}$
\end_inset

 (i.e.
 
\begin_inset Formula $S=[S_{0},S_{1},..,S_{lq-1}]$
\end_inset

 and 
\begin_inset Formula $\mathit{length(S_{i}})=ln$
\end_inset

)
\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $C$
\end_inset

 is an array of 
\begin_inset Formula $\mathit{lq}-1$
\end_inset

 sequences of length 
\begin_inset Formula $\mathit{ln}+1$
\end_inset


\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $M$
\end_inset

 is an array of 
\begin_inset Formula $\mathrm{\mathit{lq}}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathit{ln}$
\end_inset


\end_layout

\begin_layout Itemize
\noindent
\begin_inset Formula $R$
\end_inset

 is an array of 
\begin_inset Formula $\mathrm{\mathit{lq}}$
\end_inset

 sequences of length 
\begin_inset Formula $\mathrm{\mathit{ln}}$
\end_inset


\end_layout

\begin_layout Standard
Instead of writing the encoding down using the explicit 
\emph on
CNF
\emph default
 formula, we take an approach of providing an algorithm (in form of a pseudocode
) representing the steps necessary to generate such an encoding.
 We start with an empty formula 
\begin_inset Formula $\epsilon$
\end_inset

 (no clauses) and then we proceed by adding clauses derived from the 
\emph on
CNF
\emph default
 encodings of various constraints.
 In 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Generating-CNF-product"

\end_inset

, in each step we extend the output formula by the clauses derived from
 the 
\emph on
CNF
\emph default
 encoding of a particular constraint.
 
\begin_inset Formula $CNF(c)$
\end_inset

 simply denotes the 
\emph on
CNF 
\emph default
encoding of a constraint 
\begin_inset Formula $c$
\end_inset

.
 For example, 
\begin_inset Formula $CNF(A=B+C)$
\end_inset

 means the 
\emph on
CNF
\emph default
 encoding of an addition 
\begin_inset Formula $A=B+C$
\end_inset

.
 In the algorithm, we introduce some auxiliary variables and then incrementally
 we use these variables to build an encoding for the multiplication 
\begin_inset Formula $PQ$
\end_inset

.
 Please follow the comments next to the algorithm steps to understand what
 is encoded by each step.
 Last two for loops are there to fix some variables in 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 that have to have fixed values due to the nature of multiplication.
 This can be useful for efficiency reasons when solving these formulas with
 SAT solvers.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Generating 
\emph on
CNF
\emph default
 for 
\begin_inset Formula $PQ=N$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:Generating-CNF-product"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow 
\backslash
epsilon $ // starting with an empty SAT-CNF formula (no clauses)
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow CNF(S_0=P) 
\backslash
wedge f$ // generating encoding of $P$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$f 
\backslash
leftarrow CNF(S_{i}=2S_{i-1}) 
\backslash
wedge f$} // generating encodings of $2P$, $2^2P$,.., $2^{lq-1}P$
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$f 
\backslash
leftarrow CNF(M_{i}=Q_{i}S_{i}) 
\backslash
wedge f$} // generating encodings of $PQ_{0}$, $2PQ_{1}$, $2^2PQ_{2}$,..,
 $2^{lq-1}PQ_{lq-1}$
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow CNF(R_{0}=M_{0}) 
\backslash
wedge f$ // initializing partial sum encodings $R_{0}=PQ_{0}$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$f 
\backslash
leftarrow CNF(R_{i-1}+M_{i}=R_{i}) 
\backslash
wedge f$ // more partial sum encodings, $R_{i}=R_{i-1}+2^{i}PQ_{i}$, this
 requires carry=$C_{i-1}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow CNF(R_{lq-1}=N) 
\backslash
wedge f$ // encoding of the fact that last partial sum is N, $N=PQ_{0}+2PQ_{1}+..+
2^{lq-1}PQ_{lq-1}$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {each pair $(i,j)$ $
\backslash
in$ $[0,1,..,ln-1] 
\backslash
times [0,1,..,lq-1]$ } 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i+j 
\backslash
geq ln$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow (
\backslash
overline{P_{i}} 
\backslash
vee 
\backslash
overline{Q_{j}}) 
\backslash
wedge f$ // to ensure that the multiplication result does not have more
 bits than N}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$}
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i > 
\backslash
frac{lq-1}{2}$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow (
\backslash
overline{Q_{i}}) 
\backslash
wedge f$ // Limiting the number of significant bits in Q}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Encoding Nontriviality (
\begin_inset Formula $\mathbf{P\ne1,Q\ne1}$
\end_inset

)
\end_layout

\begin_layout Standard
The final step needed to reduce the 
\emph on
Integer-Factorization
\emph default
 to 
\emph on
SAT-CNF
\emph default
 is to enforce that both 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 represent nontrivial factors, i.e., that 
\begin_inset Formula $1<P<N,1<Q<N$
\end_inset

.
 There are multiple ways to do it, but the most straightforward is to demand:
\begin_inset Formula 
\[
Q\ne1,P\neq1
\]

\end_inset

Up to this point, we have shown all steps necessary to convert an arbitrary
 
\emph on
Integer-Factorization
\emph default
 problem instance to a boolean formula in 
\emph on
CN
\emph default
F.
 If the formula created in such fashion turns out to be unsatisfiable then
 we can be sure that there are no nontrivial factors for the original 
\emph on
Integer-Factorization
\emph default
 problem instance.
 On the other hand, if there is a satisfying assignment, then we can recover
 factors by looking at the part of the satisfying assignment that corresponds
 to 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Section
Reducing OWA-Winner to SAT-CNF
\begin_inset CommandInset label
LatexCommand label
name "sec:Reducing-OWA-Winner-to"

\end_inset


\end_layout

\begin_layout Standard
In this section we develop a machinery needed to reduce the 
\emph on
OWA-Winner
\emph default

\begin_inset Foot
status open

\begin_layout Plain Layout
In fact 
\emph on
OWA-Winner
\emph default
 is an optimization problem, so we will consider its decision version.
\end_layout

\end_inset

 problem to 
\emph on
SAT-CNF
\emph default
.
 To do this, we consider the 
\emph on
ILP
\emph default
 formulation of 
\emph on
OWA-Winner
\emph default
 presented in 
\begin_inset CommandInset ref
LatexCommand formatted
reference "chap:Preliminaries"

\end_inset

.
\end_layout

\begin_layout Paragraph*
Encoding Inequality between Sequences (
\begin_inset Formula $\mathbf{X\leq Y}$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

We are given two sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

:
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & Y=\langle y_{1},y_{2},..,y_{n}\rangle
\end{align*}

\end_inset

We want to define a way of comparing 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

.
 The most natural way of doing so is to adopt the definition we use when
 comparing binary expansions of integers.
 If we treat 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 in the same way as we treat the binary expansions of integers, we can write
 the following definition for 
\begin_inset Formula $X\leq Y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula $X\leq Y\iff(x_{n}<y_{n})\vee(x_{n}=y_{n}\wedge(x_{n-1}<y_{n-1}\vee...(x_{1}=y_{1}\vee(x_{1}<y_{1}))))$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

If the most significant digit of 
\begin_inset Formula $X$
\end_inset

 (
\begin_inset Formula $x_{n}$
\end_inset

) is smaller than the most significant digit of 
\begin_inset Formula $Y$
\end_inset

 (
\begin_inset Formula $y_{n}$
\end_inset

), then we know for sure that 
\begin_inset Formula $X\leq Y$
\end_inset

.
 If 
\begin_inset Formula $x_{n}=y_{n}$
\end_inset

 we keep comparing 
\begin_inset Formula $x_{n-1}$
\end_inset

 against 
\begin_inset Formula $y_{n-1}$
\end_inset

 and so on.
 We encode 
\begin_inset Formula $x_{i}<y_{i}$
\end_inset

 as 
\begin_inset Formula $(\overline{x_{i}}\wedge y_{i})$
\end_inset

.
 We also encode 
\begin_inset Formula $x_{i}=y_{i}$
\end_inset

 using the rules of logic as 
\begin_inset Formula $x_{i}\Leftrightarrow y_{i}\iff(x_{i}\Rightarrow y_{i})\wedge(y_{i}\Rightarrow x_{i})\iff(\overline{x_{i}}\vee y_{i})\wedge(\overline{y_{i}}\vee x_{i})$
\end_inset

 
\end_layout

\begin_layout Standard
Below (
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

) we provide an algorithm which constructs a boolean formula encoding for
 
\begin_inset Formula $X\leq Y$
\end_inset

.
 We simply initialize the formula 
\begin_inset Formula $f$
\end_inset

 and in the for loop we keep extending 
\begin_inset Formula $f$
\end_inset

 using the definition of 
\begin_inset Formula $X\leq Y$
\end_inset

 (going from inside to outside) and the fact that we know the encodings
 of 
\begin_inset Formula $x_{i}<y_{i}$
\end_inset

 and 
\begin_inset Formula $x_{i}=y_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.2"

\end_inset

Encoding 
\begin_inset Formula $X\leq Y$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow (
\backslash
overline{x_{1}}
\backslash
wedge y_{1})
\backslash
vee ((
\backslash
overline{x_{1}}
\backslash
vee y_{1}) 
\backslash
wedge (x_{1}
\backslash
vee 
\backslash
overline{y_{1}}))$ // encoding of $x_{1}<y_{1} 
\backslash
vee x_{1}=y_{1}$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE{$f 
\backslash
leftarrow (
\backslash
overline{x_{i}}
\backslash
wedge y_{i})
\backslash
vee (((
\backslash
overline{x_{i}}
\backslash
vee y_{i}) 
\backslash
wedge (x_{i}
\backslash
vee 
\backslash
overline{y_{i}}))
\backslash
wedge f)$} // encoding of $x_{i}<y_{i} 
\backslash
vee (x_{i}=y_{i} 
\backslash
wedge f)$
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The formula generated using algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

 is not in 
\emph on
CNF
\emph default
.
 To convert it to 
\emph on
CNF
\emph default
 efficiently, we take advantage of Tseytin transformation 
\begin_inset CommandInset citation
LatexCommand cite
key "Tseytin1968"

\end_inset

 (see Section 2.1)
\end_layout

\begin_layout Paragraph*
Encoding Inequality between a Sequence and a Constant (
\begin_inset Formula $\mathbf{X\leq I}$
\end_inset

 )
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Given a sequence 
\begin_inset Formula $X$
\end_inset

 and an integer (constant) 
\begin_inset Formula $I$
\end_inset

, which is represented as a sequence of bits
\begin_inset Formula 
\begin{align*}
 & X=\langle x_{1},x_{2},..,x_{n}\rangle\\
 & I=\langle i_{1},i_{2},..,i_{n}\rangle
\end{align*}

\end_inset

We want to encode 
\begin_inset Formula $X\leq I$
\end_inset

, which is a special case of 
\begin_inset Formula $X\leq Y$
\end_inset

.
 We define 
\begin_inset Formula $X\leq I$
\end_inset


\begin_inset Formula 
\[
X\leq I\iff(x_{n}<i_{n})\vee(x_{n}=i_{n}\wedge(x_{n-1}<i_{n-1}\vee...(x_{1}=i_{1}\vee(x_{1}<i_{1}))))
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

In the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "alg:2.3"

\end_inset

, we also go from the inside to the outside (we first consider 
\begin_inset Formula $(x_{1}=i_{1}\vee(x_{1}<i_{1}))$
\end_inset

).
 This time, however, 
\begin_inset Formula $i_{j}$
\end_inset

's are constants (values) and not variables, so we use them during the encoding
 process.
 In the line 1 of the 
\begin_inset CommandInset ref
LatexCommand formatted
reference "alg:2.3"

\end_inset

, we check if the least significant digit of 
\begin_inset Formula $I$
\end_inset

 (
\begin_inset Formula $i_{1}$
\end_inset

) is 
\begin_inset Formula $0$
\end_inset

.
 If this is true, then we demand 
\begin_inset Formula $\overline{x_{1}}.$
\end_inset

 This is because allowing 
\begin_inset Formula $x_{1}$
\end_inset

 may lead to a situation when on all other positions, except from the least
 significant position, 
\begin_inset Formula $X=I$
\end_inset

 but the least significant digit may be 
\begin_inset Formula $i_{1}=0<1=x_{1}$
\end_inset

 and hence causing 
\begin_inset Formula $X>I$
\end_inset

, which is against the requirement we want to encode: 
\begin_inset Formula $X\leq I$
\end_inset

.
 Therefore, it is only safe to demand 
\begin_inset Formula $\overline{x_{1}}.$
\end_inset

 If 
\begin_inset Formula $i_{1}$
\end_inset

 is 1 then it does not matter what we do with the least significant position
 in 
\begin_inset Formula $X$
\end_inset

.
 Therefore we may as well do not take any decision and simply assign a formula
 always true to 
\begin_inset Formula $f$
\end_inset

 (
\begin_inset Formula $x_{1}\vee\overline{x_{1}})$
\end_inset

.
 Starting from the line 6 of the algorithm, we keep building the formula
 
\begin_inset Formula $f$
\end_inset

 by extending what we have already encoded and taking the decisions similar
 to what we took for the least significant position/variable/bit.
 We can also think about the whole process of encoding in another way.
 We simply take the encoding of 
\begin_inset Formula $X\leq Y$
\end_inset

, where both 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 are sequences, and we substitute concrete values for the variables in 
\begin_inset Formula $Y$
\end_inset

.
 After the substitution, we can perform the following transformations: 
\begin_inset Formula $x_{i}<0\to\overline{x_{i}}$
\end_inset

, 
\begin_inset Formula $x_{i}<1\to(x_{i}\vee\overline{x_{i}})$
\end_inset

 to get the 
\emph on
SAT 
\emph default
encoding.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.3"

\end_inset

Encoding 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{1}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
overline{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{1}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow x_{1}
\backslash
vee 
\backslash
overline{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
FOR {$j=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{j}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
overline{x_{j}} 
\backslash
wedge f$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{j}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
overline{x_{j}} 
\backslash
vee (x_{j} 
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
noindent 
\end_layout

\end_inset

Formula expressing 
\begin_inset Formula $X\leq I$
\end_inset

 can be generated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.3"

\end_inset

.
 We can employ Tseytin transformation to convert it to 
\emph on
CNF
\emph default
.
\end_layout

\begin_layout Paragraph*
Encoding Boolean Cardinality Constraints
\end_layout

\begin_layout Standard
By now, we have all the encodings necessary to express the instances of
 
\emph on
ILP 
\emph default
as 
\emph on
SAT-CNF 
\emph default
instances
\emph on
.
 
\emph default
In this section, we consider various boolean cardinality constraints and
 their encodings, which allow us to express some specific integer linear
 programs as boolean formulas more efficiently.
 We show an efficient implementation of those constraints based on the work
 of Sinz 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard2005"

\end_inset

.
 The boolean cardinality constraints are giving bounds on how many boolean
 variables (from a given set of boolean variables) are 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
 Below we define three major types of boolean cardinality constraints (at
 most 
\begin_inset Formula $k$
\end_inset

 of, at least 
\begin_inset Formula $k$
\end_inset

 of, exactly 
\begin_inset Formula $k$
\end_inset

 of)
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define the 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{\leq k}(X)$
\end_inset

 by demanding that at most 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $X=\{x_{1},x_{2},x_{3}\}$
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

At most 
\begin_inset Formula $1$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{\leq1}(\{x_{1},x_{2},x_{3}\})$
\end_inset

 can be represented as the following boolean formula: 
\begin_inset Formula $(\overline{x_{1}}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(x_{1}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge x_{2}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge\overline{x_{2}}\wedge x_{3})$
\end_inset

.
 It enforces that there are no 
\begin_inset Formula $2$
\end_inset

 variables set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

 at the same time.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 by demanding that at least 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define 
\begin_inset Quotes eld
\end_inset

exactly 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 constraint 
\begin_inset Formula $_{=k}(X)$
\end_inset

 by demanding that exactly 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset


\end_layout

\begin_layout Remark
Let 
\begin_inset Formula $k$
\end_inset

 be an integer and let 
\begin_inset Formula $X$
\end_inset

 be a set of propositional (boolean) variables.
 The 
\begin_inset Quotes eld
\end_inset

exactly 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be encoded as a conjunction of the 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

 and the 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
In the work of Sinz 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard2005"

\end_inset

 the efficient encodings of 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 were given.
 Suppose we want to encode 
\begin_inset Formula $_{\leq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

.
 We introduce a matrix of additional variables 
\begin_inset Formula $s$
\end_inset

 such that 
\begin_inset Formula $s_{i,j}=1$
\end_inset

 iff among 
\begin_inset Formula $\{x_{1},x_{2},..,x_{i}\}$
\end_inset

 there are at least 
\begin_inset Formula $j$
\end_inset

 variables set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

 (
\begin_inset Formula $_{\geq j}(\{x_{1},x_{2},..,x_{i}\})$
\end_inset

).
 For example, 
\begin_inset Formula $s_{3,2}$
\end_inset

 indicates a subconstraint 
\begin_inset Formula $_{\geq2}(\{x_{1},x_{2},x_{3}\})$
\end_inset

.
 Let us make some observations about 
\begin_inset Formula $s_{i,j}$
\end_inset

.
 If 
\begin_inset Formula $x_{i}=1$
\end_inset

 and 
\begin_inset Formula $s_{i-1,j-1}=1$
\end_inset

, then necessarily 
\begin_inset Formula $s_{i,j}=1$
\end_inset

.
 Moreover, if 
\begin_inset Formula $s_{i-1,j}=1$
\end_inset

, then clearly 
\begin_inset Formula $s_{i,j}=1$
\end_inset

.
 These two observations together with boundary conditions allowed Sinz to
 encode 
\begin_inset Formula $_{\leq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

.
 Below we state the theorem about encoding 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 efficiently.
 The meaning of variables is as discussed above.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard2005"

\end_inset


\begin_inset space ~
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:LT-encoding"

\end_inset

Encoding 
\begin_inset Formula $LT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\leq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as follows:
\begin_inset Formula 
\begin{align*}
 & (\overline{x_{1}}\vee s_{1,1})\\
 & (\overline{s_{1,j}}) & 1<j\leq k\\
 & (\overline{x_{i}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{s_{i-1,1}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,j-1}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{s_{i-1,j}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,k}}) & 1<i<n\\
 & (\overline{x_{n}}\vee\overline{s_{n-1,k}})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
In the Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:LT-encoding"

\end_inset

 the variable 
\begin_inset Formula $s_{i,j}$
\end_inset

 asserts that among 
\begin_inset Formula $i$
\end_inset

 variables 
\begin_inset Formula $\{x_{1},x_{2},..,x_{i}\}$
\end_inset

 at least 
\begin_inset Formula $j$
\end_inset

 variables are set to 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

.
 Below we state the corollary that allows us to encode 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 efficiently.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "thm:GT-encoding"

\end_inset

 Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}.$
\end_inset

 Encoding 
\begin_inset Formula $GT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as a 
\begin_inset Formula $LT_{SEQ}^{n,n-k}$
\end_inset

 encoding with all variables from 
\begin_inset Formula $X$
\end_inset

 negated.
\end_layout

\begin_layout Proof
Corollary 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:GT-encoding"

\end_inset

 is simply obtained by using the fact that the condition 
\begin_inset Quotes eld
\end_inset

at least 
\begin_inset Formula $k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 variables are 
\begin_inset Formula $\mathrm{TRUE}$
\end_inset

 is the same as 
\begin_inset Quotes eld
\end_inset

at most 
\begin_inset Formula $n-k$
\end_inset

 of
\begin_inset Quotes erd
\end_inset

 variables are 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
 The variable 
\begin_inset Formula $s_{i,j}$
\end_inset

 asserts that among 
\begin_inset Formula $i$
\end_inset

 variables 
\begin_inset Formula $\{x_{1},x_{2},..,x_{i}\}$
\end_inset

 at least 
\begin_inset Formula $j$
\end_inset

 variables are set to 
\begin_inset Formula $\mathrm{FALSE}$
\end_inset

.
 We need to negate all the occurrences of 
\begin_inset Formula $x_{j}$
\end_inset

 variables, because we are only counting variables set to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathrm{FALSE}$
\end_inset

 in this case.
\end_layout

\begin_layout Paragraph*
Encoding Decision Version of OWA-Winner Problem
\end_layout

\begin_layout Standard
Let us state the decision version of the 
\emph on
OWA-Winner
\emph default
 problem based on the 
\emph on
ILP
\emph default
 formulation from Chapter 1.
 Decision version of the 
\emph on
OWA-Winner
\emph default
 problem reduces to checking feasibility of the following integer linear
 program:
\begin_inset Formula 
\begin{align*}
 & (a):\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L & L\in\mathbb{{N}}\\
 & (b):\sum_{i=1}^{m}y_{i}=K\\
 & (c):x_{i,j,k}\leq y_{j} & ,i\in[n];j\in[m];k\in[K]\\
 & (d):\sum_{j=1}^{m}x_{i,j,k}=1 & ,i\in[n];k\in[K]\\
 & (e):\sum_{k=1}^{K}x_{i,j,k}\leq1 & ,i\in[n];j\in[m]\\
 & (f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset

Having stated what we mean by the decison version of the 
\emph on
OWA-Winner
\emph default
 problem, we finally present a way of encoding an arbitrary 
\emph on
OWA-Winner
\emph default
 problem instances as a 
\emph on
SAT-CNF
\emph default
 formula.
 
\begin_inset Formula $CNF(c)$
\end_inset

 simply denotes the 
\emph on
CNF 
\emph default
encoding of a constraint 
\begin_inset Formula $c$
\end_inset

 e.g.
 
\begin_inset Formula $CNF(A=B+C)$
\end_inset

 means the CNF encoding of an addition 
\begin_inset Formula $A=B+C$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-OWA-Winner-problem"

\end_inset

Decision OWA-Winner problem instances can be encoded as SAT-CNF formulas
 in the following way:
\begin_inset Formula 
\begin{align*}
 & (a):CNF(\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L) & L\in\mathbb{{N}}\\
 & (b):CNF(_{=K}(\{y_{j}|j\in[m]\}))\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):CNF(_{=1}(\{x_{i,j,k}|j\in[m]\})) & ,i\in[n];k\in[K]\\
 & (e):CNF(_{\leq1}(\{x_{i,j,k}|k\in[K]\})) & ,i\in[n];j\in[m]\\
 & (f):CNF(\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)}) & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We need to show that constraints (a) - (h) are expressible using 
\emph on
SAT-CNF
\emph default
 encodings constructed so far.
 Constraints (g) and (h) are clearly just declaring sets of propositional
 variables: 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and therefore produce no clauses in a 
\emph on
CNF
\emph default
 encoding.
 Constraint (a) is simply an inequality between a sequence constructed from
 sum of products and an integer (
\begin_inset Formula $S\geq L$
\end_inset

 and 
\begin_inset Formula $S=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}$
\end_inset

).
 So, while being quite costly (in terms of number of variables and clauses)
 it is expressible in the 
\emph on
SAT-CNF
\emph default
 format.
\end_layout

\begin_layout Proof
Similarly, for constraint (f) we can write 
\begin_inset Formula $S_{1}\geq S_{2}$
\end_inset

 where 
\begin_inset Formula $S_{1}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{1}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}$
\end_inset

) and 
\begin_inset Formula $S_{2}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{2}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)}$
\end_inset

).
 Constraint (c) is a simple clause logically equivalent to: 
\begin_inset Formula $(x_{i,j,k}\Rightarrow y_{j})$
\end_inset

, which behaves like 
\begin_inset Formula $x_{i,j,k}\leq y_{j}$
\end_inset

.
 Constraints (b), (d) and (e) are all boolean cardinality constraints for
 which we have already shown efficient encodings.
\end_layout

\begin_layout Standard
Constraints (a) and (f) are the most costly elements in the model.
 In the next section we will look at a somewhat restricted version of decision
 
\emph on
OWA-Winner
\emph default
 problem in which these constraints are simplified.
\end_layout

\begin_layout Paragraph*
Encoding Decision Version of k-Best-OWA-Approval-Winner Problem
\end_layout

\begin_layout Standard
As we saw in the previous subsection, it is possible to convert any 
\emph on
Decision
\emph default
 
\emph on
OWA-Winner
\emph default
 problem instance to a
\emph on
 SAT-CNF
\emph default
 formula.
 It is prohibitevely expensive to encode constraints (a) and (f) from Theorem
 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:Encoding-OWA-Winner-problem"

\end_inset

 (requiring lots of sequence multiplications).
 In this subsection we present more restricted yet still computationally
 demanding version of Decision 
\emph on
OWA-Winner
\emph default
 problem.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "Decision-version-of-k-Best-OWA-Approval"

\end_inset

Decision version of 
\emph on
k-Best-OWA-Approval-Winner
\emph default
 problem is obtained from Decision version of the 
\emph on
OWA-Winner
\emph default
 problem by:
\end_layout

\begin_layout Itemize
Requiring an OWA vector 
\begin_inset Formula $\alpha$
\end_inset

 and a derived utility 
\begin_inset Formula $u$
\end_inset

 to be binary (
\begin_inset Formula $\alpha_{i}\in\{0,1\},u_{i,a_{j}}\in\{0,1\}$
\end_inset

).
 
\end_layout

\begin_layout Itemize
Removing the following constraint: 
\begin_inset Formula $(f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset

, which basically is not needed when 
\begin_inset Formula $\alpha$
\end_inset

 is non-increasing.
\end_layout

\begin_layout Standard

\emph on
SAT-CNF
\emph default
 encoding of Decision 
\emph on
k-Best-OWA-Approval-Winner
\emph default
 problem follows:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-Decision-k-Best-OWA-Approval"

\end_inset

Encoding Decision k-Best-OWA-Approval-Winner problem instances as SAT-CNF
 formulas
\begin_inset Formula 
\begin{align*}
 & (a):CNF(_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\}))\\
 & (b):CNF(_{=K}(\{y_{j}|j\in[m]\}))\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):CNF(_{=1}(\{x_{i,j,k}|j\in[m]\})) & ,i\in[n];k\in[K]\\
 & (e):CNF(_{\leq1}(\{x_{i,j,k}|k\in[K]\})) & ,i\in[n];j\in[m]\\
 & (f):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (g):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We take the 
\emph on
SAT-CNF
\emph default
 encoding of a decision version of the general 
\emph on
OWA-Winner 
\emph default
problem.
 We remove 
\begin_inset Formula $\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset

 constraints.
 We know that 
\begin_inset Formula $\alpha_{k}u_{i,a_{j}}$
\end_inset

 has to be either 
\begin_inset Formula $0$
\end_inset

 or 
\begin_inset Formula $1$
\end_inset

 (
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 are binary in the approval version of the problem).
 This fact allows us to replace the summation 
\begin_inset Formula $\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L$
\end_inset

 with 
\begin_inset Formula $\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}x_{i,j,k}\geq L$
\end_inset

 for 
\begin_inset Formula $i$
\end_inset

,
\begin_inset Formula $j$
\end_inset

,
\begin_inset Formula $k$
\end_inset

 such that 
\begin_inset Formula $\alpha_{k}u_{i,a_{j}}=1$
\end_inset

.
 Finally, we can write the summation as a boolean cardinality constraint
 
\begin_inset Formula $_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\})$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesisExample"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
