#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}
 \renewcommand{\sectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsectionautorefname}{sec.\negthinspace}
 \renewcommand{\subsubsectionautorefname}{sec.\negthinspace}
 \renewcommand{\figureautorefname}{Fig.\negthinspace}
 \renewcommand{\tableautorefname}{Tab.\negthinspace}
}
\@ifpackageloaded{babel}{\addto\extrasenglish{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% enables algorithmic crap
\usepackage{algorithmic}

% enables multirow editing
\usepackage{multirow}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage,fleqn
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Your title"
\pdf_author "Your name"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Reducing selected computational problems to SAT-CNF
\end_layout

\begin_layout Section
Basic notions and definitions
\end_layout

\begin_layout Standard
Below we introduce vocabulary used in the following sections.
\end_layout

\begin_layout Standard
Most of the terms should be familiar and self-explanatory.
\end_layout

\begin_layout Definition

\series bold
Boolean variable 
\begin_inset Formula $x$
\end_inset

 
\series default
- variable taking values from 
\begin_inset Formula $\{0,1\}$
\end_inset

 (being either FALSE or TRUE)
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition

\series bold
Sequence (of boolean variables)
\series default
 
\begin_inset Formula $<x_{1},x_{2},x_{3},..,x_{n}>$
\end_inset

- ordered collection of boolean variables of fixed size
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition

\series bold
Length of a sequence 
\series default
- number of boolean variables associated with a sequence.
 
\begin_inset Formula $length(<x_{1},x_{2},..,x_{n}>)=n$
\end_inset


\end_layout

\begin_layout Standard
Sequences of length 
\begin_inset Formula $n$
\end_inset

 can be used to represent 
\begin_inset Formula $n-bit$
\end_inset

 integers.
 Each variable in a sequence is representing exactly one bit of an integer.
 
\end_layout

\begin_layout Remark
When using sequence 
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset

 to represent integers we stick to the convention that 
\begin_inset Formula $x_{1}$
\end_inset

 corresponds to the least significant bit and 
\begin_inset Formula $x_{n}$
\end_inset

 corresponds to the most significant bit.
\end_layout

\begin_layout Section
Reducing Integer Factorization to SAT-CNF
\end_layout

\begin_layout Standard
Since Integer Factorization problem belongs to class 
\begin_inset Formula $NP$
\end_inset


\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It is easy to verify given 
\begin_inset Formula $n$
\end_inset

 and numbers 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 if 
\begin_inset Formula $n=pq$
\end_inset

 It is enough to compute product 
\begin_inset Formula $pq$
\end_inset

 which can be easily done in polynomial time and compare it to 
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset

 there is a way to reduce it to SAT-CNF in polynomial time.
 
\end_layout

\begin_layout Standard
Arguably, the most direct way of doing it is to encode multiplication circuit
 as a SAT-CNF formula.
 
\end_layout

\begin_layout Standard
One of such encodings is available in: 
\begin_inset CommandInset citation
LatexCommand cite
key "Srebrny2004"

\end_inset


\end_layout

\begin_layout Standard
Following subsections contain descriptions of various constraints.
 The main goal of each subsection is to establish either a CNF encoding
 for a given constraint or an algorithm producing such an encoding.
\end_layout

\begin_layout Subsection
Encoding equality of sequences 
\begin_inset Formula $X=Y$
\end_inset


\end_layout

\begin_layout Standard
To represent equality between sequences 
\begin_inset Formula $X$
\end_inset

 and 
\begin_inset Formula $Y$
\end_inset

 it suffices to encode 'variable-wise' equality
\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=<y_{1},y_{2},..,y_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=Y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}(x_{i}\Leftrightarrow y_{i})
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((\overline{x_{i}}\vee y_{i})\wedge(x_{i}\vee\overline{y_{i}}))
\]

\end_inset

 (in conjunctive normal form)
\end_layout

\begin_layout Subsection
Encoding not equality between sequence and integer 
\begin_inset Formula $X\ne I$
\end_inset


\end_layout

\begin_layout Standard
This type of constraint is especially useful when we want to enforce that
 some sequence 
\begin_inset Formula $X$
\end_inset

 is 
\series bold
not
\series default
 equal given integer 
\begin_inset Formula $I$
\end_inset

.
 For example we may wish that our factor 
\begin_inset Formula $X$
\end_inset

 (represented by sequence) is not equal 
\begin_inset Formula $1$
\end_inset


\end_layout

\begin_layout Standard
For this to hold we need to encode 
\begin_inset Formula $X\ne1$
\end_inset

 constraint as a SAT-CNF formula (set of clauses)
\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $I$
\end_inset

- integer
\end_layout

\begin_layout Standard
\begin_inset Formula $X\ne I$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\bigvee_{i=1}^{n}y_{i}
\]

\end_inset

where: 
\begin_inset Formula $y_{i}=x_{i}$
\end_inset

 if 
\begin_inset Formula $i-th$
\end_inset

 bit of 
\begin_inset Formula $I$
\end_inset

 is 
\begin_inset Formula $0$
\end_inset

 (If 
\begin_inset Formula $i-th$
\end_inset

 bit of 
\begin_inset Formula $I$
\end_inset

 is 
\begin_inset Formula $1$
\end_inset

 then 
\begin_inset Formula $y_{i}=\overline{x_{i}}$
\end_inset

)
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $I=13$
\end_inset

 and 
\begin_inset Formula $X=<x_{1},x_{2},x_{3},x_{4}>$
\end_inset

 Constraint 
\begin_inset Formula $X\ne I$
\end_inset

 can be encoded as 
\begin_inset Formula $(\overline{x_{1}}\vee x_{2}\vee\overline{x_{3}}\vee\overline{x_{4}})$
\end_inset

 
\end_layout

\begin_layout Subsection
Encoding shift equality constraint 
\begin_inset Formula $Y=2^{i}X$
\end_inset


\end_layout

\begin_layout Standard
This constraint is basically stating that after shifting 
\begin_inset Formula $X$
\end_inset

 by 
\begin_inset Formula $i$
\end_inset

 positions to the left we obtain 
\begin_inset Formula $Y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=<y_{1},y_{2},..,y_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=2^{i}X$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
(\bigwedge_{j=1}^{i}\overline{y_{j}})\wedge\bigwedge_{j=i+1}^{n}((y_{j}\vee\overline{x_{j-i}})\wedge(\overline{y_{j}}\vee x_{j-i}))
\]

\end_inset


\end_layout

\begin_layout Subsection
Encoding left variable-wise multiplication 
\begin_inset Formula $bX=Y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $b$
\end_inset

 - boolean variable
\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=<y_{1},y_{2},..,y_{n}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $bX=Y\iff(b\wedge x_{1},b\wedge x_{2},..,b\wedge x_{n})=(y_{1},y_{2},..,y_{n})$
\end_inset

 (meaning of left variable-wise multiplication)
\end_layout

\begin_layout Standard
\begin_inset Formula $bX=Y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\bigwedge_{i=1}^{n}((b\vee\overline{y_{i}})\wedge(x_{i}\vee\overline{y_{i}})\wedge(y_{i}\vee\overline{b}\vee\overline{x_{i}}))
\]

\end_inset


\end_layout

\begin_layout Subsection
Encoding addition 
\begin_inset Formula $X+Y=Z$
\end_inset


\end_layout

\begin_layout Standard
In order to encode addition constraint between sequences we need to introduce
 additional sequence 
\begin_inset Formula $C$
\end_inset

 representing carry bits.
\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{0},x_{1},..,x_{n-1}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Y=<y_{0},y_{1},..y_{n-1}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $Z=<z_{0},z_{1},..,z_{n-1}>$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $C=<c_{0},c_{1},..,c_{n}>$
\end_inset

(Please note that carry sequence has length of 
\begin_inset Formula $n+1$
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset Formula $X+Y=Z$
\end_inset

 (with carry 
\begin_inset Formula $C$
\end_inset

):
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (\overline{c_{0}})\wedge(\overline{c_{n}})\\
 & \wedge\bigwedge_{i=1}^{n}((\overline{c_{i}}\vee x_{i-1}\vee c_{i-1})\wedge(\overline{c_{i}}\vee x_{i-1}\vee y_{i-1})\wedge(\overline{c_{i}}\vee y_{i-1}\vee c_{i-1})\\
 & \wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{c_{i-1}})\wedge(c_{i}\vee\overline{x_{i-1}}\vee\overline{y_{i-1}})\wedge(c_{i}\vee\overline{y_{i-1}}\vee\overline{c_{i-1}}))\\
 & \wedge\bigwedge_{i=0}^{n-1}((z_{i}\vee y_{i}\vee x_{i}\vee\overline{c_{i}})\wedge(z_{i}\vee y_{i}\vee\overline{x_{i}}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee x_{i}\vee c_{i})\wedge(z_{i}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee\overline{c_{i}})\\
 & \wedge(\overline{z_{i}}\vee y_{i}\vee x_{i}\vee c_{i})\wedge(\overline{z_{i}}\vee y_{i}\vee\overline{x_{i}}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee x_{i}\vee\overline{c_{i}})\wedge(\overline{z_{i}}\vee\overline{y_{i}}\vee\overline{x_{i}}\vee c_{i}))
\end{align*}

\end_inset


\end_layout

\begin_layout Subsection
Encoding multiplication 
\begin_inset Formula $PQ=N$
\end_inset


\end_layout

\begin_layout Standard
Formula for computing product of two numbers 
\begin_inset Formula $n=pq$
\end_inset

 can be expressed as:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
pq=q_{0}p+q_{1}2p+q_{2}2^{2}p+...+q_{k-1}2^{k-1}p
\]

\end_inset

Careful reader can notice that formula above is basically a 
\series bold
sum of shift multiplications
\series default
 for which we have already shown appropriate encodings.
 We need a lot of additional variables (and sequences) to construct CNF
 encoding of 
\begin_inset Formula $PQ=N$
\end_inset

.
 
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $ln=length(N)$
\end_inset

 and 
\begin_inset Formula $lq=length(Q)$
\end_inset


\end_layout

\begin_layout Standard
Below is a summary of additional sequences used to construct CNF encoding
 of 
\begin_inset Formula $PQ=N$
\end_inset

:
\end_layout

\begin_layout Itemize
\begin_inset Formula $S$
\end_inset

- array of 
\begin_inset Formula $lq$
\end_inset

 sequences of length 
\begin_inset Formula $ln$
\end_inset

 (i.e.
 
\begin_inset Formula $S=[S_{0},S_{1},..,S_{lq-1}]$
\end_inset

 and 
\begin_inset Formula $length(S_{i})=ln$
\end_inset

) 
\end_layout

\begin_layout Itemize
\begin_inset Formula $C$
\end_inset

- array of 
\begin_inset Formula $lq-1$
\end_inset

 sequences of length 
\begin_inset Formula $ln+1$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $M$
\end_inset

- array of 
\begin_inset Formula $lq$
\end_inset

 sequences of length 
\begin_inset Formula $ln$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $R$
\end_inset

- array of 
\begin_inset Formula $lq$
\end_inset

 sequences of length 
\begin_inset Formula $ln$
\end_inset


\end_layout

\begin_layout Standard
Instead of writing the encoding down using explicit CNF formula we take
 approach of providing an algorithm (in form of pseudocode) representing
 the steps necessary to generate such an encoding: 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Generating-CNF-product"

\end_inset


\end_layout

\begin_layout Standard
Each step represent constraint(s) that has to be added.
\end_layout

\begin_layout Standard
Last two for loops are there just to fix some variables in 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 in order to explicitely decrease search space.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Generating CNF for 
\begin_inset Formula $PQ=N$
\end_inset


\begin_inset CommandInset label
LatexCommand label
name "alg:Generating-CNF-product"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $S_0=P$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$S_{i}=2S_{i-1}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$M_{i}=Q_{i}S_{i}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $R_{0}=M_{0}$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=1$ 
\backslash
TO $lq-1$} 
\backslash
STATE{$R_{i-1}+M_{i}=R_{i}$ // carry=$C_{i-1}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
STATE $R_{lq-1}=N$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {each pair $(i,j)$ $
\backslash
in$ $[0,1,..,ln-1] 
\backslash
times [0,1,..,lq-1]$ } 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i+j 
\backslash
geq ln$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$(
\backslash
bar{P_{i}} 
\backslash
vee 
\backslash
bar{Q_{j}})$ // to ensure that multiplication result does not have more
 bits than N}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=0$ 
\backslash
TO $lq-1$}
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i > 
\backslash
frac{lq-1}{2}$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$(
\backslash
bar{Q_{i}})$ // Limiting number of significant bits in Q}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Encoding multiplication 
\begin_inset Formula $PQ=N,1<P<N,1<Q<N$
\end_inset


\end_layout

\begin_layout Standard
The final step to reduce Integer Factorization to SAT-CNF is to enforce
 that both 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset

 represent nontrivial factors i.e.
 
\begin_inset Formula $1<P<N,1<Q<N$
\end_inset


\end_layout

\begin_layout Standard
There are multiple ways to do it, but the most straightforward is to demand:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
Q\ne1
\]

\end_inset


\end_layout

\begin_layout Standard
Up to this point we have shown all steps necessary to convert arbitrary
 Integer Factorization problem instance to boolean formula in CNF form.
\end_layout

\begin_layout Standard
If a formula created in such fashion turns out to be 
\begin_inset Formula $UNSAT$
\end_inset

 then we can be sure that there are no nontrivial factors to original Integer
 Factorization problem instance (number is prime).
\end_layout

\begin_layout Standard
If there is a satisfying assignment then we can recover factors by looking
 at part of the satisfying assignment that corresponds to 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $Q$
\end_inset


\end_layout

\begin_layout Section
Reducing OWA-Winner to SAT-CNF
\end_layout

\begin_layout Standard
In this section we develop a machinery needed to reduce OWA-Winner
\begin_inset Foot
status open

\begin_layout Plain Layout
In fact OWA-Winner is an optimization problem, so we will consider it's
 decision version.
\end_layout

\end_inset

 problem to SAT-CNF.
 To do this we will consider ILP formulation of OWA-Winner problem presented
 in Chapter 1
\end_layout

\begin_layout Subsection
Encoding inequality between sequences 
\begin_inset Formula $X\leq Y$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset

 - 
\begin_inset Formula $x_{1}$
\end_inset

 is the least significant digit, 
\begin_inset Formula $x_{n}$
\end_inset

 is the most significant digit
\end_layout

\begin_layout Standard
\begin_inset Formula $Y=<y_{1},y_{2},..,y_{n}>$
\end_inset

 - 
\begin_inset Formula $y_{1}$
\end_inset

 is the least significant digit, 
\begin_inset Formula $y_{n}$
\end_inset

 is the most significant digit
\end_layout

\begin_layout Standard
\begin_inset Formula $X\leq Y\iff(x_{n}<y_{n})\vee(x_{n}=y_{n}\wedge(x_{n-1}<y_{n-1}\vee...(x_{1}=y_{1}\vee(x_{1}<y_{1}))))$
\end_inset


\end_layout

\begin_layout Standard
Below (
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

) we provide an algorithm which constructs a boolean formula for 
\begin_inset Formula $X\leq Y$
\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.2"

\end_inset

Encoding 
\begin_inset Formula $X\leq Y$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
STATE $f 
\backslash
leftarrow (
\backslash
bar{x_{1}}
\backslash
wedge y_{1})
\backslash
vee ((
\backslash
bar{x_{1}}
\backslash
vee y_{1}) 
\backslash
wedge (x_{1}
\backslash
vee 
\backslash
bar{y_{1}}))$
\end_layout

\begin_layout Plain Layout


\backslash
FOR {$i=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
STATE{$f 
\backslash
leftarrow (
\backslash
bar{x_{i}}
\backslash
wedge y_{i})
\backslash
vee (((
\backslash
bar{x_{i}}
\backslash
vee y_{i}) 
\backslash
wedge (x_{i}
\backslash
vee 
\backslash
bar{y_{i}}))
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Formula generated using algorithm 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.2"

\end_inset

 is not in CNF.
 To convert it to CNF in efficient manners we take advantage of Tseytin
 transformation 
\begin_inset CommandInset citation
LatexCommand cite
key "Tseytin1968"

\end_inset


\end_layout

\begin_layout Subsection
Encoding inequality between sequence and integer 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula $X=<x_{1},x_{2},..,x_{n}>$
\end_inset

 - 
\begin_inset Formula $x_{1}$
\end_inset

 is the least significant digit, 
\begin_inset Formula $x_{n}$
\end_inset

 is the most significant digit
\end_layout

\begin_layout Standard
\begin_inset Formula $I=<i_{1},i_{2},..,i_{n}>$
\end_inset

 - binary encoding of integer 
\begin_inset Formula $I$
\end_inset

.
 
\begin_inset Formula $i_{1},i_{2},..,i_{n}$
\end_inset

 - bits
\end_layout

\begin_layout Standard
\begin_inset Formula $X\leq I$
\end_inset

 is a special case of 
\begin_inset Formula $X\leq Y$
\end_inset

 .
 Because of that we can obtain more efficient encoding of 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "alg:2.3"

\end_inset

Encoding 
\begin_inset Formula $X\leq I$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{1}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{1}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow x_{1}
\backslash
vee 
\backslash
bar{x_{1}}$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
FOR {$j=2$ 
\backslash
TO $n$} 
\end_layout

\begin_layout Plain Layout


\backslash
IF {$i_{j}=0$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{j}} 
\backslash
wedge f$}
\end_layout

\begin_layout Plain Layout


\backslash
ELSIF {$i_{j}=1$}
\end_layout

\begin_layout Plain Layout


\backslash
STATE {$f 
\backslash
leftarrow 
\backslash
bar{x_{j}} 
\backslash
vee (x_{j} 
\backslash
wedge f)$}
\end_layout

\begin_layout Plain Layout


\backslash
ENDIF
\end_layout

\begin_layout Plain Layout


\backslash
ENDFOR
\end_layout

\begin_layout Plain Layout


\backslash
RETURN $f$
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Formula experssing 
\begin_inset Formula $X\leq I$
\end_inset

 can be generated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:2.3"

\end_inset

.
 We can employ Tseytin transformation to convert it to CNF.
\end_layout

\begin_layout Subsection
Encoding boolean cardinality constraints
\end_layout

\begin_layout Standard
In this section we will consider different boolean cardinality constraints
 and their encodings.
 We will show an efficient implementation of those constraints based on
 the work in 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset


\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define at most 
\begin_inset Formula $k$
\end_inset

 of constraint 
\begin_inset Formula $_{\leq k}(X)$
\end_inset

 by demanding that at most 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $TRUE$
\end_inset


\end_layout

\begin_layout Example
Let 
\begin_inset Formula $X=\{x_{1},x_{2},x_{3}\}$
\end_inset

 .
 At most 
\begin_inset Formula $1$
\end_inset

 of 
\begin_inset Formula $X$
\end_inset

 constraint 
\begin_inset Formula $_{\leq1}(\{x_{1},x_{2},x_{3}\})$
\end_inset

 can be represented as a following boolean formula: 
\begin_inset Formula $(\overline{x_{1}}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(x_{1}\wedge\overline{x_{2}}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge x_{2}\wedge\overline{x_{3}})\vee(\overline{x_{1}}\wedge\overline{x_{2}}\wedge x_{3})$
\end_inset

.
 It enforces that there are no 
\begin_inset Formula $2$
\end_inset

 variables set to 
\begin_inset Formula $TRUE$
\end_inset

 at the same time.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define at least 
\begin_inset Formula $k$
\end_inset

 of constraint 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 by demanding that at least 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $TRUE$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $X=\{x_{1},x_{2},..,x_{n}\}$
\end_inset

 be a set of boolean variables.
 We define exactly 
\begin_inset Formula $k$
\end_inset

 of constraint 
\begin_inset Formula $_{=k}(X)$
\end_inset

 by demanding that exactly 
\begin_inset Formula $k$
\end_inset

 variables from 
\begin_inset Formula $X$
\end_inset

 are set to 
\begin_inset Formula $TRUE$
\end_inset


\end_layout

\begin_layout Remark
Let 
\begin_inset Formula $k\in\mathbb{{N}}$
\end_inset

 and 
\begin_inset Formula $X$
\end_inset

 be a set of propositional (boolean) variables.
 Let 
\begin_inset Formula $CNF({}_{\leq k}(X))$
\end_inset

 be a CNF encoding of 
\begin_inset Formula $_{\leq k}(X)$
\end_inset

 , 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $CNF({}_{\geq k}(X))$
\end_inset

 be a CNF encoding of 
\begin_inset Formula $_{\geq k}(X)$
\end_inset

 and 
\begin_inset Formula $CNF({}_{=k}(X))$
\end_inset

 be a CNF encoding of 
\begin_inset Formula $_{=k}(X)$
\end_inset

.
 The following holds:
\end_layout

\begin_layout Remark
\begin_inset Formula 
\[
CNF({}_{=k}(X))=CNF({}_{\leq k}(X))\wedge CNF({}_{\geq k}(X))
\]

\end_inset


\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:LT-encoding"

\end_inset

Encoding 
\begin_inset Formula $LT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\leq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as follows:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (\overline{x_{1}}\vee s_{1,1})\\
 & (\overline{s_{1,j}}) & 1<j\leq k\\
 & (\overline{x_{i}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{s_{i-1,1}}\vee s_{i,1}) & 1<i<n\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,j-1}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{s_{i-1,j}}\vee s_{i,j}) & 1<i<n,1<j\leq k\\
 & (\overline{x_{i}}\vee\overline{s_{i-1,k}}) & 1<i<n\\
 & (\overline{x_{n}}\vee\overline{s_{n-1,k}})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Proof of theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:LT-encoding"

\end_inset

 is available in 
\begin_inset CommandInset citation
LatexCommand cite
key "SinzCard"

\end_inset


\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "thm:GT-encoding"

\end_inset

Encoding 
\begin_inset Formula $GT_{SEQ}^{n,k}$
\end_inset

 expressing 
\begin_inset Formula $_{\geq k}(\{x_{1},x_{2},..,x_{n}\})$
\end_inset

 
\begin_inset Formula $n>1,k>0$
\end_inset

 can be stated as follows:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (x_{1}\vee\overline{s_{1,1}})\\
 & (\overline{s_{1,j}}) & 1<j\leq k\\
 & (\overline{s_{i,j}},s_{i-1,j-1}) & 1<i\leq n,1<j\leq k\\
 & (\overline{s_{i,j}},s_{i-1,j},x_{i}) & 1<i\leq n,1<j\leq k\\
 & (\overline{s_{i,1}},s_{i-1,1},x_{i}) & 1<i\leq n\\
 & (s_{n,k})
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Proof: Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:GT-encoding"

\end_inset

 is simply obtained by applying the same technique used to construct 
\begin_inset CommandInset ref
LatexCommand ref
reference "thm:LT-encoding"

\end_inset


\end_layout

\begin_layout Subsection
Encoding decision version of OWA-Winner problem
\end_layout

\begin_layout Standard
Let's state decision version of OWA-Winner problem based on ILP formulation
 from Chapter 1
\end_layout

\begin_layout Definition
Decision version of OWA-Winner problem reduces to checking feasibility of
 following integer linear program:
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L & L\in\mathbb{{N}}\\
 & (b):\sum_{i=1}^{m}y_{i}=K\\
 & (c):x_{i,j,k}\leq y_{j} & ,i\in[n];j\in[m];k\in[K]\\
 & (d):\sum_{j=1}^{m}x_{i,j,k}=1 & ,i\in[n];k\in[K]\\
 & (e):\sum_{k=1}^{K}x_{i,j,k}\leq1 & ,i\in[n];j\in[m]\\
 & (f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Standard
Having stated what we mean by decison version of OWA-Winner problem we can
 finally present a way of encoding arbitrary OWA-Winner problem instances
 as a SAT-CNF formula.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-OWA-Winner-problem"

\end_inset

Encoding Decision OWA-Winner problem instances as SAT-CNF formulas
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}\geq L & L\in\mathbb{{N}}\\
 & (b):_{=K}(\{y_{j}|j\in[m]\})\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):_{=1}(\{x_{i,j,k}|j\in[m]\}) & ,i\in[n];k\in[K]\\
 & (e):_{\leq1}(\{x_{i,j,k}|k\in[K]\}) & ,i\in[n];j\in[m]\\
 & (f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)} & ,i\in[n];k\in[K-1]\\
 & (g):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (h):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We need to show that constraints (a) - (h) are expressible using SAT-CNF
 encodings constructed so far.
 (g) and (h) are clearly just declaring sets of propositional variables:
 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, and therefore producing no clauses in a CNF encoding.
 Constraint (a) is simply an inequality between sequence constructed from
 
\series bold
sum of products
\series default
 and integer (
\begin_inset Formula $S\geq L$
\end_inset

 and 
\begin_inset Formula $S=\sum_{i=1}^{n}\sum_{j=1}^{m}\sum_{k=1}^{K}\alpha_{k}u_{i,a_{j}}x_{i,j,k}$
\end_inset

) so in spite of being quite costly (in terms of number of variables and
 clauses) it is expressible in SAT-CNF format.
\end_layout

\begin_layout Proof
Similarly for (f) we can write 
\begin_inset Formula $S_{1}\geq S_{2}$
\end_inset

 where 
\begin_inset Formula $S_{1}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{1}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}$
\end_inset

) and 
\begin_inset Formula $S_{2}$
\end_inset

 is a sequence (
\begin_inset Formula $S_{2}=\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)}$
\end_inset

) .
 (c) is a simple clause logically equivalent to: 
\begin_inset Formula $(x_{i,j,k}\Rightarrow y_{j})$
\end_inset

, which behaves as 
\begin_inset Formula $x_{i,j,k}\leq y_{j}$
\end_inset

.
 (b), (d), (e) are all boolean cardinality constraints for which we have
 already shown one efficient encoding.
\end_layout

\begin_layout Standard
(a) and (f) are the most costly constraints in the model.
 In the next section we will look at a slightly restricted version of decision
 OWA-Winner problem.
\end_layout

\begin_layout Subsection
Encoding decision version of Binary OWA-Winner problem
\end_layout

\begin_layout Standard
As we saw in the previous subsection it is possible to convert any Decision
 OWA-Winner problem instance to SAT-CNF formula.
 It is prohibitevely expensive to encode constraints (a) and (f) (requiring
 lots of sequence multiplications).
 In this subsection we will present more restricted yet still computationally
 demanding version of Decision OWA-Winner problem.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "Decision-version-of-Binary-OWA"

\end_inset

Decision version of Binary OWA-Winner problem is obtained from Decision
 version of OWA-Winner problem by:
\end_layout

\begin_layout Itemize
Forcing 
\begin_inset Formula $\alpha$
\end_inset

 - OWA vector and 
\begin_inset Formula $u$
\end_inset

 - derived utility to be binary (
\begin_inset Formula $\alpha_{i}\in\{0,1\},u_{i,a_{j}}\in\{0,1\}$
\end_inset

) 
\end_layout

\begin_layout Itemize
Removing following constraint: 
\begin_inset Formula $(f):\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset


\end_layout

\begin_layout Standard
SAT-CNF encoding of Decision Binary OWA-Winner problem follows:
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "thm:Encoding-Decision-Binary"

\end_inset

Encoding Decision Binary OWA-Winner problem instances as SAT-CNF formulas
\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Formula 
\begin{align*}
 & (a):_{\geq L}(\{x_{i,j,k}|i\in[n],j\in[m],k\in[K],\alpha_{k}u_{i,a_{j}}>0\})\\
 & (b):_{=K}(\{y_{j}|j\in[m]\})\\
 & (c):(\overline{x_{i,j,k}},y_{j}) & ,i\in[n];j\in[m];k\in[K]\\
 & (d):_{=1}(\{x_{i,j,k}|j\in[m]\}) & ,i\in[n];k\in[K]\\
 & (e):_{\leq1}(\{x_{i,j,k}|k\in[K]\}) & ,i\in[n];j\in[m]\\
 & (f):x_{i,j,k}\in\{0,1\} & ,i\in[n];j\in[m];k\in[K]\\
 & (g):y_{j}\in\{0,1\} & ,j\in[m]
\end{align*}

\end_inset


\end_layout

\begin_layout Proof
We remove 
\begin_inset Formula $\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,k}\geq\sum_{j=1}^{m}u_{i,a_{j}}x_{i,j,(k+1)},i\in[n];k\in[K-1]$
\end_inset

 constraints.
 We can easily see that 
\begin_inset Formula $\alpha_{k}u_{i,a_{j}}$
\end_inset

 has to be either 0 or 1 (
\end_layout

\begin_layout Standard
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "thesisExample"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
